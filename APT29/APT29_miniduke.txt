miniduke
by admin on february 27, 2013 leave a comment
earlier in february 2013, fireeye announced the discovery of a new malware that exploited a 0-day vulnerability in adobe reader. now, we announce another, as yet unknown malware that exploits the same adobe reader vulnerability (cve-2013-0640). this new malware was named miniduke by kaspersky labs with whom we carried out its first analysis. our participation in this research was justified by a detected hungarian incident. a detailed report on the results of our joint efforts has been published by kaspersky labs on their securelist blog site. that report describes what we currently know about the operation of miniduke including its stages, and also information on the c&c infrastructure and communications. we have published another report from crysys lab that contains information on the indicators of miniduke infections and gives specific hints on its detection. this blog entry is a brief excerpt of our report. the available malware samples are highly obfuscated, and compiled by a polymorphic compiler. the attackers were able to produce new variants with only a few minutes difference between compile times. therefore, the number of distinct samples could be very large. hashes of known samples are published in our detailed report on indicators. due to a large number of compiled samples, there is a high chance that the current version is difficult to detect by signatures. yet, there are common features in the samples that can be used to identify the malware components. in every case we encountered, the program files/startup contains a file with .lnk extension after installation. this is used to start up the malware after the computer is rebooted. a not fully cross-checked information is that, during installation, the malware will be copied in two copies on the system and the two executables differ. this might mean that the executable modifies itself. for example, we recovered the following two files: where base.cat is the startup file, which is created based on ~ . base.cat is stored in the all users directory, whereas ~ is stored in a user s directory, e.g., in the guest user directory as c:\documents and settings\guest\local settings\application data\~ . this user directory contains at least one more file, update.cmd, with a specific content that could be used for detection. as for stage 3 of the attack, it is important to note that it is not yet analyized deeply. so once a victim downloads the ~300k long piece of stage 3 code, we don t know what happens with the previous stages, and we have no information about detections once this stage is reached, except the usage of the c&c server . another variant of the stage 3 code is much smaller, only 14k long, and connects to a server in turkey. we have identified the following servers delivering stage 2 and stage 3 code to victims: the c&c server used by stage 3 of the malware is (ip ) and it is located in panama. there are multiple layers of c&c communications in the malware. first, the malware uses google search to receive information from its master. then, it uses the twitter messaging service looking for the twits of a specific twitter user. commands received via this channel trigger the download of stage 2 and stage 3 code. basic detection can be based on the queries that are initiated by the victim computer within seconds: known search strings in google search can also be used to detect the malware: unfortunately, these strings are most likely unique to each c&c server or victim, thus unknown samples might use other strings, but possibly with the same length. examples for twits containing the url of the c&c server are shown below: the malware also sends a query to the geoiptool. an example is shown below: the malware retrieves the url of the stage 2/3 delivery c&c server from twitter messages as described above. then, we can observe the first query from the victim towards the server. this query contains pure http traffic on port 80 to the server following the template below. where: shortname can be a number of strings, generally human readable (e.g. lib, engine, forum, forumengine etc.) e= is not constant, can be anything, but generally 1-2 letters long
aaaaaaaaa stands for some base64-like text (see details below)
the servers used are assumed to be legitimate sites, just hacked by the attackers.
based on this format, we can detect a valid query as follows: the name of the first get parameter should be discarded this means e= is not important
we saw only one get parameter, queries with multiple parameters are likely not used
for detection, the base64-like string aaa should be first modified as follows: this results in correct base64 encoding, which can be decoded with library functions such as base64_decode. after decoding, a string of data, partially binary, will be available. parts are separated by the delimiter character | . the format and a numerical example are below: as the binary data itself may contain the | character, parsing should start from the end (i.e., the numerical id starts from the second | character from the end). in additional, the id length may vary (not fully confirmed), but it seems to be around 10 digits. finally, the version number always follows the pattern one digit.two digits , e.g., 1.1x 3.1x.
