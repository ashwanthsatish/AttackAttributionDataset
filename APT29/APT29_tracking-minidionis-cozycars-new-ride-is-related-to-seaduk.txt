executive summary
unit 42 has uncovered a new campaign from the cozyduke threat actors, aka cozycar [1], leveraging malware that appears to be related to the seaduke malware described earlier this week by symantec. [2] this campaign, which began on july 7, 2015, appears to be targeted at government organizations and think-tanks located in democratic countries [3], and utilizes compromised, legitimate websites for spear phishing and command and control activity. unit 42 discovered the extent of this attack using the palo alto networks autofocus service, which allows analysts to quickly find correlations among malware samples analyzed by wildfire. all files referenced throughout the analysis are contained in the ioc table at the end of this blog. malware details
the initial droppers: decoy and downloader
the current cozycar campaign includes spear phishing emails that deliver the payload from either by a link to a .zip file on a compromised website or by direct delivery as an attachment to the phish. at the time of our analysis, the phishing link was no longer active. when a user opens the attached file a poorly detected executable file [vt 1/54] is extracted. the initial dropper is a self-extracting archive (sfx). upon execution, this executable file will drop two files in the %temp% directory: a decoy .wav file and the secondary dropper. the cozyduke group commonly uses legitimate media files to trick users. in reality, while the media a .wav file with a female voice claiming to be a reporter looking for commentary is played, the secondary dropper executes in the background. the secondary dropper requests a .swf file using ssl as illustrated in the http traffic below. as of this writing, the domain extranet.qualityplanning[.]com resolved to 64.244.34[.]200. the secondary dropper then cleans up after itself with a simple vbs script (md5: ) that leaves only the decoy multimedia file behind. but what did the dropper do with the .swf file? the real payload
while the file downloaded by the second stage dropper does contain media, it is, again, a decoy. the actual flash component of this file is roughly 16kb, leaving approximately 200kb of the file unaccounted for. the second stage dropper contains decoding routines that decode the arbitrary binary data into an executable file. the executable file is dropped in %appdata%/roaming and appears to try and emulate legitimate software names: timbuktudaemon, searchindexer, rtkaudioservice64, dirmngr, o2flash, and usbrefs64. this file was not observed on virustotal until july 9 and has extremely low detection rates [vt: 3/54]. it appears that the authors of this particular iteration of the cozycar group s malware internally call it minidionis according to pdb strings left in the binary ( ). it also appears to be an iteration on the forkmeimfamous aka seaduke malware analyzed by unit 42 in a previous blog [4]. the malware stores 2 files in the %temp% directory: a configuration file and a secondary dll. the configuration file s name matches the final characters of the bot_id that is contained within as per the sample below: analysis of the secondary dll file (name matches [a-z0-9]{1} ) indicates that its primary function is to serve as a cleanup mechanism for the dropped binary. this is likely an attempt to thwart forensic investigations. further examination of memory dumps taken following the execution of minidionis reveals some clues into the beaconing activity exhibited. the malware stores configuration values in memory as key:value pairs:
the configuration of minidionis is a json blob with several important sections, which are described in the table below: network communications
the functional payload of this trojan starts by creating a mutex by splitting the bot_id value in the configuration on the hyphen ( - ) and using the second portion of the split string (specifically, 01mrlxw in the case of this configuration). from a functionality standpoint, the trojan uses the concept of tasks that are processed and completed using a pool of threads. to obtain tasks, the trojan will issue an https request to the c2 server ( host_scripts in the configuration) that resembles the following example beacon:
the trojan manually creates the cookie in this http request. the cookie contains ciphertext that the trojan creates based on the bot_id in the json configuration. the trojan compresses the bot_id string using zlib and then encrypts it using the rc4 algorithm using a generated key. the generated key is a sha1 hash of two randomly created strings: the first of which is between 2 and 8 bytes long and the second is between 1 and 7 characters in length. the ciphertext of the bot_id is then based64 encoded and finally the appended to the cookie_name ( ssid= ) in the configuration and sent within the http request to the c2 server. unit 42 did not observe the first random string (between 2 and 8 characters in length) sent to the c2 in the first beacon, which would be required by the c2 to reproduce the exact sha1 hash used as a key to generate the ciphertext in the cookie. upon further examination we believe that the c2 will not be able to decrypt the cookie in the first beacon. instead, the c2 will respond to the first beacon with data that the trojan will use to extract a string, using a function named trextractkey seen in figure 2, to replace the first random string used to generate the sha1 hash. once the c2 and trojan have synchronized using this string, the c2 will be able to decrypt subsequent network beacons because the trojan includes the random string between 1 and 7 characters that makes up the second half of the sha1 hash within the cookie field before the ciphertext. the c2 communications, and several of the commands we will discuss in this blog, include a rather interesting technique to manually handle http redirection, such as the http 301 moved permanently and http 302 found status codes. the technique used to handle these redirections involves checking for the presence of a location field within the http headers of the server response, then using regular expressions to parse the html within server response to find the appropriate url. the code contains three regular expressions to parse the html to locate the url, the first of which is <a.*?>.*?</a> that locates all of the tags associated with link within the html. the second regular expression of onclick=\ accept();\ locates only links within the html with a specific onclick action. the last regular expression of href\\s*=\\s*(?:[\ ](?<1>[^\ ]*)[\ ]|(?<1>\\s+)) to obtain the correct url to interact with as the c2 server. command handler
once the c2 and trojan have synchronized and can decrypt their network communications the c2 server will begin responding to beacons from the trojan with json blobs. unit 42 has not received any json blobs from an active c2 server, but based on static analysis of the trojan determined the json would look as follows:
the trojan takes this json blob and adds each task in the list into a pool for processing. separate worker threads access this pool of tasks and process the commands and perform the necessary activities. unit 42 analyzed the trojan s command handler and found several commands, as seen in table 2, which allows the threat actors to carry out a full range of activities on the system. conclusion
the actors behind the cozyduke framework are highly sophisticated, motivated, and have become increasingly bold in their campaigns. we recommend that other security practitioners review the included indicators of compromise (iocs) to ensure they have not been targets in this campaign, and add the appropriate security controls to prevent future attacks. this group is reliant on social engineering, and thus, user education remains of paramount importance. palo alto networks customers using wildfire were protected from this campaign. all known elements of this campaign have been accurately identified by wildfire as malicious. 