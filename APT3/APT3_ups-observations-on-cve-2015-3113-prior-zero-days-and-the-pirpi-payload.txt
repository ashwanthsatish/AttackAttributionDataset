ups: observations on cve-2015-3113, prior zero-days and the pirpi payload
robert falcone	by robert falcone and richard wartell july 27, 2015 at 1:50 pm category: malware, threat prevention, unit 42 tags: actionscript, adobe flash, apt3, autofocus, internet explorer, operation clandestine wolf, pirpi, shellcode, steganography, ups, wildfire, zero-days a june 23 fireeye blog post titled operation clandestine wolf discussed a cyber espionage group, known as apt3, that had been exploiting a zero-day vulnerability in adobe flash. unit 42 also tracks the apt3 group using the name ups, which is an intrusion set with chinese origins that is known for having early access to zero-day vulnerabilities and delivering a backdoor called pirpi. the ups group has exploited several zero-day vulnerabilities, most recently using the zero-days released in the hacking team breach that we discussed in our july 10 blog post, apt group ups targets us government with hacking team flash exploit . however, the most recent original zero-day released by this group is tracked by cve-2015-3113, which has similarities to the once zero-day vulnerabilities cve-2014-1776 and cve-2014-6332 exploited by ups in may and november 2014, respectively. we ll discuss here the similarities observed between the various components used to exploit these two vulnerabilities, specifically focusing on the malicious flash files and the payloads delivered. malicious flash files
recent zero-day vulnerabilities exploited by ups exploit or leverage adobe flash to exploit other applications on the system. unit 42 recently analyzed malicious flash files that exploited cve-2015-3113, which was a zero-day vulnerability in adobe flash that was patched on june 23, 2015.. during the analysis, we noticed similarities between this malicious flash file, those that ups used to exploit cve-2014-1776, and the proof-of-concept code for cve-2014-6332, albeit these two flash files were used to exploit zero-day vulnerabilities in internet explorer. overlaps within actionscript
unit 42 analyzed the actionscript within malicious flash files created by ups that exploited cve-2014-1776 and cve-2015-3113 and discovered shared code between the two. first, both actionscripts contain a function named hextointarray , which figure 1 displays side-by-side for comparison. not only do these files contain the same function name, but they also share the same exact operation codes (opcodes) to carry out its functionality. the existence of the hextointarray function in the cve-2015-3113 sample is rather interesting, as it is never called or used within the actionscript. we believe that the threat actor used the cve-2014-1776 actionscript as the basis for the cve-2015-3113 file and forgot to remove the unused hextointarray function. cve-2014-1776	cve-2015-3113
function private::hextointarray(string):__as3__.vec::vector.<int>
{
0 getlocal0
1 pushscope
2 pushnull
3 coerce_a
4 setlocal2
5 getlocal1
6 getproperty length
8 coerce_a
9 setlocal3
10 pushbyte 0
12 coerce_a
13 setlocal 4
15 getlex vector
17 getlex int
19 applytype (1)
21 getlocal3
22 pushbyte 2
24 divide
25 construct (1)
27 coerce __as3__.vec::vector.<int>
29 setlocal 5
31 pushbyte 0
33 coerce_a
34 setlocal 6
36 jump l1l2:
40 label
41 getlocal1
42 getlocal 4
44 callproperty http:// (1)
47 getlocal1
48 getlocal 4
50 pushbyte 1
52 add
53 callproperty http:// (1)
56 add
57 coerce_a
58 setlocal2
59 getlocal 5
61 getlocal 6
63 findpropstrict parseint
65 getlocal2
66 pushbyte 16
68 callproperty parseint (2)
71 setproperty null
73 getlocal 4
75 pushbyte 2
77 add
78 coerce_a
79 setlocal 4
81 getlocal 6
83 pushbyte 1
85 add
86 coerce_a
87 setlocal 6l1:
89 getlocal 4
91 getlocal3
92 iflt l2
96 getlocal 5
98 returnvalue
} function private::hextointarray(string):__as3__.vec::vector.<int>
{
0 getlocal0
1 pushscope
2 pushnull
3 coerce_a
4 setlocal2
5 getlocal1
6 getproperty length
8 coerce_a
9 setlocal3
10 pushbyte 0
12 coerce_a
13 setlocal 4
15 getlex vector
17 getlex int
19 applytype (1)
21 getlocal3
22 pushbyte 2
24 divide
25 construct (1)
27 coerce __as3__.vec::vector.<int>
29 setlocal 5
31 pushbyte 0
33 coerce_a
34 setlocal 6
36 jump l1l2:
40 label
41 getlocal1
42 getlocal 4
44 callproperty http:// (1)
47 getlocal1
48 getlocal 4
50 pushbyte 1
52 add
53 callproperty http:// (1)
56 add
57 coerce_a
58 setlocal2
59 getlocal 5
61 getlocal 6
63 findpropstrict parseint
65 getlocal2
66 pushbyte 16
68 callproperty parseint (2)
71 setproperty null
73 getlocal 4
75 pushbyte 2
77 add
78 coerce_a
79 setlocal 4
81 getlocal 6
83 pushbyte 1
85 add
86 coerce_a
87 setlocal 6l1:
89 getlocal 4
91 getlocal3
92 iflt l2
96 getlocal 5
98 returnvalue
} figure 1. side-by-side comparison of opcodes in hextointarray functions also, the flash file exploiting cve-2015-3113 had a main class named flappyman . this class name was also used in the flash file that unit 42 analyzed and discussed in its november 26, 2014 blog titled addressing cve-2014-6332 swf exploit , as well as the proof-of-concept (poc) for cve-2014-6332 that is now publicly available in exploit-related forums. according to fireeye s operation double tap , ups exploited cve-2014-6332 in its november 2014 attacks; however, ups used a vbscript to exploit the vulnerability instead of a flash file. while purely speculation, this overlap in class names between the cve-2014-6332 poc and the flash file exploiting cve-2015-3113 may suggest that ups also used flash files to exploit cve-2014-6332. shellcode similarities
as with most remote code execution vulnerabilities, ups malicious documents execute shellcode in the event of successful exploitation of either cve-2014-1776 or cve-2015-3113. the shellcode found in the ups delivery documents exploiting both of these vulnerabilities are not the same, but have similarities worth noting. first, the delivery documents share the same technique of locating api functions, which involves using the rotate right (ror 7 to be specific) instruction on the function name in and checking it with a specific value. the use of the same rotate right algorithm results in several common constants, such as 0xc917432 that both shellcodes use to locate loadlibrarya. second, both shellcodes use a similar method of creating the unicode string , seen in figure 2. the shellcodes use the unicode string and the same method to find the base address of the loaded module from the ldr structures obtained from the process environment block (peb). third, both shellcodes have similar single byte xor algorithms used to decrypt and later execute the functional payload. pirpi1 figure 2. comparison of instructions in ups shellcodes that builds unicode string steganography to conceal payloads
while analyzing the malicious flash file exploiting cve-2015-3113, unit 42 discovered that the actionscript loaded an animated gif image. the malware author used steganography to embed an encrypted payload within this animated gif image. the payload in the cve-2014-1776 was also embedded within an animated gif. ultimately, the shellcode executed in the event of successful exploitation of either of these vulnerabilities decrypt and execute the embedded payload, as mentioned in the previous section. while the animated gifs themselves are vastly different, as seen in figure 3 and 4 (payloads removed), the use of steganography and animated images as the carrier of the payload is common between the two campaigns. .stripped.payload figure 3. animated gif from ups campaign exploiting cve-2015-3113 (click to see .gif) 2777r3sh11ge[1] figure 4. animated gif from ups campaign exploiting cve-2014-1776 payload comparison
with the amount of overlap between the other components in these separate campaigns, we decided to compare the pirpi payloads delivered by the ups group using cve-2014-1776 and cve-2015-3113. from here on, we will refer to these two payloads as pirpi.2014 (cve-2014-1776) and pirpi.2015 (cve-2015-3113), whose details are listed in table 1. unit 42 discovered several similarities between the two pirpi variants, as well as a few equally important differences, both of which are worth discussing. we also compared the pirpi.2014 and pirpi.2015 payloads to other known pirpi samples in an attempt to determine which variant they most closely resemble. file name	file type	architecture	size
md5	compile time
sha256 (pirpi.2014) x86	86016 04:29:14 00:44:04 {cve-2015-3113 payload} (pirpi.2015) x86	150528 06:07:15 01:51:27 table 1. file details of pirpi.2014 and pirpi.2015 samples similarities in c2 communications
both pirpi variants perform an initial check to see if a configuration file exists at %appdata% or %temp% depending on the operating system. if it finds one, it decodes it and uses the configuration data it finds inside for c2 communication, otherwise it uses hardcoded c2 domains encoded inside the binary. the malware then creates threads to begin c2 communication. the pirpi.2014 and pirpi.2015 payloads communicate with their c2 by issuing http get requests to the c2 domain hardcoded inside the payload or within its configuration file. while the structure of the c2 url differs between the two variants, both use the http cookie field to transmit data in encrypted form to the c2 domain. figure 6 shows examples of c2 communications from pirpi.2014 and figure 7 shows communication with the c2 of pirpi.2015 malware variants, both containing data within the cookie field. pirpi5 figure 5. pirpi.2014 c2 communication using cookie field for exfiltration pirpi6 figure 6. pirpi.2015 c2 communication using cookie field for exfiltration the get request will return a web page that the malware will parse, specifically looking for encoded commands within two of the html tags. command loop overlap
once the two pirpi variants successfully communicate with their c2 server and parse the returned html for commands, pirpi enters a command loop that processes the commands and carries out the respective activities. the command loop for the backdoor remains largely unchanged between pirpi.2014 and pirpi.2015 with only two of the commands differing between the two. table 2 shows the commands that each malware can accept with only the 35 and 36 commands differing between the two pirpi variants. value	pirpi.2014 command	pirpi.2015 command
1	launch process
2	process listing
3	terminate process
4	download a file from the c2, launch it, and then delete it
5	exit the malware
6	sleep
7	update c2 configuration and save it to %appdata% 8	download a file, load it into memory, then delete the file
9	load a dll from %appdata% and execute one of its exported functions
10	do nothing
11	do nothing
12	list all servers in the domain
13	get network adaptor information
14	list tcp connection status (netstat)
15	retrieve information about connected users
16	list servers in the primary domain
17	locates dcs on a domain
32	directory listing
33	upload a file to the c2
34	delete file
35	copy file and delete original	copy file
36	download and save file	do nothing
37	echo
38	execute process
49	get location of configuration file and set as current working directory
table 2. commands available within pirpi.2014 and pirpi.2015 anti-disassembly
the ups threat group is a fan of one anti-disassembly trick that can be seen in both pirpi.2014 and pirpi.2015. it plays upon the order ida pro disassembles instructions. as you can see in the code sample in figure 6 from pirpi.2014 there is a jump above instruction, followed by a jump below or equal instruction which just falls through to the next instruction. this fall-through code path will never get executed since the jump occurs if 0x58693c96 > 0x0d7f31b4. pirpi7 figure 7. code showing anti-disassembly technique used in pirpi tool ida pro s disassembly sequence follows the fall-through branch of conditional jumps first, and thus in the previous instruction sequence, ida keeps disassembling one instruction after another. when ida goes back to disassemble the jump target for 0x10009133, it finds it pointing to the middle of an instruction. this stops ida from being able to draw function borders, view a function in graph mode, or decompile with hex-rays. to solve this, undefine all of the code that will not be executed, and define code starting from the target of the conditional branch (in this case 0x1000913e), as seen in figure 7. pirpi8 figure 8. fixing anti-disassembly trick used by pirpi tool by undefining errant instructions you will now be able to create a function to improve your ability to do analysis. to make this easier, use an ida pro script to fix these anti-disassembly tricks. please note that this script specifically targets the anti-disassembly used in pirpi and other ups samples. it may cause issues with malware that uses other anti-disassembly tricks. use with caution. notable differences
the first major difference between the pirpi.2014 and pirpi.2015 variants is in the way the command loop is executed in each backdoor. in pirpi.2014, the malware uses a simple state machine that executes code blocks that correspond to a state value, which the malware updates at the end of each code block. many of these code blocks include sleep functions, however, if the state value is set to the correct value, the malware executes a code block that contains the command loop. the purpose of this state machine is to intentionally delay the malware s execution of the command loop. in pirpi.2015, the malware implements a second state machine that executes the pirpi.2014 state machine as one of its code blocks. the second state machine introduces a large number of randomized sleep functions, causing the malware to take much longer to execute its command loop. the majority of code blocks in the second state machine either sleep, or create threads and wait for them to finish. the malware author likely implemented these state machines as an anti-debugging technique and to defeat most modern sandbox solutions. the second difference between the two pirpi variants involves the encoding algorithm, which has improved greatly in the past year. contained in the binary is an invertible math function for encoding and decoding of data. in pirpi.2014 this function is rather simple, involving a few mathematical operations. however, in pirpi.2015, the algorithm when decompiled is more than 300 source code lines of mathematical operations. other pirpi samples
fireeye released two reports in 2014 about apt3 phishing campaigns, operation doubletap and operation clandestine fox. each report containins md5s of other pirpi samples that were available on virustotal. in addition, simple virustotal searches resulted in a few more pirpi samples that came from the same code base. table 3 contains the file information for each of these pirpi samples. file name	file type	architecture	size
md5	compile time
sha256
{fireeye report sample} x86	102400 09:25:14 09:09:59 x86	81920 09:10:14 04:54:09 x86	86016 05:27:14 08:48:13 x86	86016 04:29:14 00:45:45 x86	81920 04:29:14 00:32:43 table 3. details of pirpi samples from fireeye reports and samples that share the same code base the sample listed as {fireeye report sample} in table 3 is simply a dropper and loader for sample. unit 42 compared all of the dll samples listed in the table above and found that they are most closely related to pirpi.2014. table 4 below shows the statistics from zynamics bindiff from comparing each of the dlls with pirpi.2014 and pirpi.2015. sample md5	pirpi.2014 bindiff	pirpi.2015 bindiff
similarity	confidence	similarity	confidence 89.5%	98.6%	29.8%	69.5% 92.7%	98.8%	29.4%	69.5% 91.4%	98.7%	29.6%	71.6% 93.7%	98.7%	30.7%	71.6% 100%	100%	34.3%	73.0% 34.3%	73.0%	100%	100%
table 4. resulting similarity and confidence rates of pirpi samples conclusion
the ups threat group continues to exploit zero-day vulnerabilities in their campaigns, which shows that this group is quite sophisticated and has access to significant resources. within their attack campaigns involving zero-days, ups has consistently reused delivery techniques and code within various components of the attack. ups has relied on steganography to conceal the payloads delivered after exploitation of zero-days by embedding payloads, specifically the pirpi backdoor within animated gifs. this group also reuses portions of their actionscript within their malicious flash files used to exploit vulnerabilities, as well as sharing portions of shellcode that executes after exploitation. in regards to similarities amongst payloads, ups delivers variants of the pirpi backdoor that are typically very similar to each other. the pirpi backdoors we analyzed use the same configuration file, a common c2 communications channel and a similar command handler. also, the author of pirpi includes several notable fingerprints within the code, specifically using a unique state machine and anti-disassembly techniques. organizations can use all of these overlaps and similarities to track and hopefully protect themselves from this advanced adversary. autofocus users can identify pirpi payloads with the pirpi tag (figure 9). wildfire automatically classifies pirpi samples as malicious and we have released ips signature 14643 to detect pirpi c2 communications. pirpi tag figure 9. pirpi tag 