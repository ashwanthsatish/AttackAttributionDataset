01/20/2015, author: paul rascagn res
analysis of project cobra
another extensible framework used by the uroburos actors
project cobra and the carbon system were mentioned by kaspersky in the article called the epic turla operation . this malware is used by the same actors as uroburos (aka snake/turla) and agent.btz. we estimate that carbon system was developed after agent.btz and before uroburos. the carbon system shares some technical details with uroburos and agent.btz (encryption key, encryption algorithm, design, ) and some other links, such as the name of the snake-related project: cobra. uroburos could be considered as a kernel centric snake and cobra carbon system as a userland centric snake . one specification of the group behind this threat is the fact that when they developed new tools, the old ones are not destroyed or abandoned but still maintained and used. thanks to our collection of samples we are able to draw the following timeline: the cobra can be considered as an extensible framework. this framework is generally downloaded and dropped by a reconnaissance malware for example tavdig, aka wipbot (symantec) or also epic backdoor (kaspersky). the following schema illustrates the modus opandi used by the uroburos actors: using ioc (indicators of compromise) to detect this malware is quite complicated, because the malware authors made efforts to randomize many factors. for example, the attackers drop the malware into different directories, using the files present, also chosen randomly, to store the malware configuration. due to these characteristics, the experts of the g data securitylabs decided to publish an analysis of the framework dropped by the file with the md5: . g data security solutions detect this file as backdoor.turlacarbon.a (engine a) and (engine b). we can find the compilation path in a file embedded in the dropper: looking at this, we can easily identify that carbon system is a part of the cobra project. dropper
the dropper is used to install four files on the infected system. the dropped files are stored in the resources of the binary. the dropper has the 32-bit and the 64-bit version of the executable files embedded. it installs the following files: : configuration file;
stage 1: the file name is randomly chosen from , or . this library is registered as a service;
stage 2: the file name is . it s the orchestrator of the malware (called system by the author);
stage 3: the file name is . this library (called user by the authors) is injected in the browsers and the email clients in order to communicate to the outside via web requests.
the persistence is performed by the creation of a service (hklm\system\currentcontrolset\service\). the service name depends on the chosen stage 1 file name: stage 1 is always installed in %systemroot%\system32\
to install something into %systemroot%, the attackers have to have gained administration privileges before they executed the dropper. the three other dropped files are stored in an existing directory in %programfiles%, randomly chosen. during the installation, executed in a command line, the dropper displays the following information: the screenshot shows the string lucky strike!!! , displayed in case the installation was carried out successfully and idioten??? in case of any installation error. to be able to find the random installation path, the dropper modifies a legitimate .inf file (also chosen randomly) in %systemroot%\inf\ to add the following information to the end of the file: the id between the brackets is a unique id and the root variable contains the path in which the three additional files are installed. the tricks put in place by the authors random file names and random installation paths are used to limit the detection possible with indicators of compromise. generally, security researchers use these kinds of artifacts in order to detect the compromise of systems. g data security solutions detect this as backdoor.turlacarbon.a (engine a) and win32.trojan.cobra.a (engine b). the first stage is rather small as the number of instructions and actions is rather small. simply spoken, its purpose is to load the second stage. to perform this task, the first stage checks all of the files in %systemroot%\inf\ in order to find the entry with the unique id previously mentioned and therefore to determine the path for stage 2. after that, the library of the second stage is loaded and, subsequently, the exported function modulestart() is executed: g data security solutions detect this threat as backdoor.turlacarbon.a (engine a) and (engine b). the second stage is called system by the authors of the malware. the internal name of the library is . the purpose of this code is to stay in background and orchestrate several requests and tasks made by the other .dlls or named pipe connections. mutex creation
the orchestrator creates several mutexes. these mutexes are used for two reasons: used by the third stage in order to detect whether the orchestrator has been launched correctly on the infected system;
used to execute the orchestrator only once.
here are the created mutexes: the websites listed in [cw_inet] and [cw_inet_results] are all compromised legitimate wordpress websites. by the time of writing this article, all websites have been cleaned and patched. the file format is the same as the .ini file format from windows. the authors use the windows api to parse the configuration (getprivateprofilestringa()).
the file contains: a unique id to identify the infected machine (object_id);
the command and control server used by stage 3 (addressx);
the version of the system and the user library (in [version]);
the frequency and time of execution of several internal tasks ([time]);
the name of the named pipe used as communication channel between the system and the user (system_pipe);
the process name where stage 3 will be injected (iproc); communication via named pipes
the orchestrator creates two named pipes in order to communicate with stage 3 or to receive messages from an external machine: features
the orchestrator creates nine threads in order to handle the different features. we will now have a look at the most interesting threads. one thread is used to check if the parameters in the configuration file have changed. a second thread is used to check the available hard disk space. if the hdd space is low, the orchestrator generates an entry in the log file: the preceding screenshot reveals a rather interesting use of english, again. from what we can conclude, we believe survive me is supposed to mean something like rescue me in the sense of help me to survive . a third thread is created in order to handle the tasks. a task is a command sent from the c&c that is to be executed. the code to be executed is stored locally on the infected machine. the orchestrator is able to execute libraries (by executing the export start()) or to execute windows command line. the command line can be execute with the current user privilege or with the privilege of another user (via createprocessa() or createprocessasusera()): a fourth thread is used to handle the log rotation file (vndkrmn.dic). a fifth thread is used to create and read the data sent to the named pipes. a sixth thread is used to load plugins. for the orchestrator a module is a library file with a specific export called modulestart(). the plugin list is stored in the configuration file ([plugins]). this thread is very similar to the third thread, but is bares some minor differences. the function to execute the plugins is not the same. finally a seventh thread is used to inject stage 3 ( ) into the browsers and email clients. the list of the targeted processes is stored in the configuration file:
iproc = , , , , , as usual, the injected library is executed via the modulestart() exports. his threat is detected by g data security solutions as backdoor.turlacarbon.a (engine a) and (engine b). stage 3 is called user by the authors. the internal name of the library is .
the purpose of this stage is to communicate to the outside via web requests. the communication is used to ex-filtrate data and to receive orders (or plugins or code to execute). mutex check
the first task of stage 3 is to check whether the mutexes created by the orchestrator are available or not, to make sure the orchestrator has started correctly: check of the internet connection
before communicating with the command and control server, stage 3 checks whether an internet connection is available by contacting: communication to the command & controls
the communication to the operators is performed via the url stored in the configuration file. firstly, the malware performs a get request in order to identify whether the c&c is up and running. if the first query is a success, a second request is sent to the c&c with the difference that some data is included into an http cookie. the content of the cookie is catid, task, id, forumid, itemid, link, layout, start, limit (none of the parameters is mandatory). the data sent in this cookie is encrypted, using the cast-128 algorithm, and encoded. the malware can also generate post requests. here is an example of the pattern:
the malware uses the same technique as tavdig does to receive orders. the data can be seen between the <div> and the </div> field in the following screenshot: additional features
stage 3 is able to execute tasks, exactly as the orchestrator is. the code concerning the features is exactly the same as the code the orchestrator uses. we assume that this is the case due to copy & paste. the user is able to execute libraries (by executing the export start()) and to execute windows command line. the command line can be executed with the current user privilege or with the privilege of another user (via createprocessa() or createprocessasusera()). conclusion
this analysis shows us that the actors behind uroburos, agent.btz and the carbon system are skilled and still active. this sample we analyzed demonstrates how the authors tried to complicate the detection and the use of indicators of compromise. summarized, some of the tricks we have encountered: use of random service names;
us of random file names;
use of random installation directory names;
configuration of the named pipe name; carbon system is a real extensible framework with a plugin management. as these plugins are provided by the contacted c&c servers, it can be anything nothing has to be pre-bundled. due to the nature of the malware attacks, we can imagine those plugins to be anything connected to cyber espionage, from keyloggers to credentials stealers, eavesdropping mechanisms and much more. an attacked enterprise or organization would be an open book for the attackers. the architecture is complex, with an orchestrator and a library injected into the browsers and email clients processes. obviously, this approach resembles what we have seen looking at uroburos. the framework could be considered as a draft but still very powerful version (in user-land only) of uroburos. we believe that uroburos is the product of the cobra malware evolution. although uroburos is a new branch, not a linear follow-up. looking at the whole picture that we can draw until now, we can say that everything regarding this whole campaign is highly professional. we have analyzed various samples and have drawn many conclusions. even though there are still many open questions that need to be answered, we come closer to charming the snakes the cobra, the venomous animal with the deadly bite, and uroburos, the self-sustaining creepy mixture of a snake and a dragon. this kind of herpetology became quite interesting and we are thrilled to find out more about the campaigns.
