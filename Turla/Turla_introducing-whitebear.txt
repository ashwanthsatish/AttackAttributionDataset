introducing whitebear
by great on august 30, 2017. 2:43 pm
as a part of our kaspersky apt intelligence reporting subscription, customers received an update in mid-february 2017 on some interesting apt activity that we called whitebear. much of the contents of that report are reproduced here. whitebear is a parallel project or second stage of the skipper turla cluster of activity documented in another private intelligence report skipper turla the white atlas framework from mid-2016. like previous turla activity, whitebear leverages compromised websites and hijacked satellite connections for command and control (c2) infrastructure. as a matter of fact, whitebear infrastructure has overlap with other turla campaigns, like those deploying kopiluwak, as documented in kopiluwak a new javascript payload from turla in december 2016. whitebear infected systems maintained a dropper (which was typically signed) as well as a complex malicious platform which was always preceded by whiteatlas module deployment attempts. however, despite the similarities to previous turla campaigns, we believe that whitebear is a distinct project with a separate focus. we note that this observation of delineated target focus, tooling, and project context is an interesting one that also can be repeated across broadly labeled turla and sofacy activity. from february to september 2016, whitebear activity was narrowly focused on embassies and consular operations around the world. all of these early whitebear targets were related to embassies and diplomatic/foreign affair organizations. continued whitebear activity later shifted to include defense-related organizations into june 2017. when compared to whiteatlas infections, whitebear deployments are relatively rare and represent a departure from the broader skipper turla target set. additionally, a comparison of the whiteatlas framework to whitebear components indicates that the malware is the product of separate development efforts. whitebear infections appear to be preceded by a condensed spearphishing dropper, lack firefox extension installer payloads, and contain several new components signed with a new code signing digital certificate, unlike whiteatlas incidents and modules. the exact delivery vector for whitebear components is unknown to us, although we have very strong suspicion the group spearphished targets with malicious pdf files. the decoy pdf document above was likely stolen from a target or partner. and, although whitebear components have been consistently identified on a subset of systems previously targeted with the whiteatlas framework, and maintain components within the same filepaths and can maintain identical filenames, we were unable to firmly tie delivery to any specific whiteatlas component. whitebear focused on various embassies and diplomatic entities around the world in early 2016 tellingly, attempts were made to drop and display decoy pdf s with full diplomatic headers and content alongside executable droppers on target systems. technical details
the whitebear platform implements an elaborate set of messaging and injection components to support full presence on victim hosts. a diagram helps to visualize the reach of injected components on the system. the whitebear binary loader maintains several features including two injection methods for its (oddly named) kernelinjector subsystem, also named by its developer standart windowinject (includes an unusual technique for remotely placing code into memory for subsequent thread execution) the loader also maintains two methods for privilege and dep process protection handling:
loader runtime flow
the pipe is used to communicate with the target process and the transport module; the running code also reads its own image body and writes it to the pipe. the loader then obtains the payload body from resource binary 202. it finds the running process that matches the target name, copies the buffer containing the payload into the process, then starts its copy in the target process. there are some interesting, juvenile, and non-native english-speaker debug messages compiled into the code: the main module has no exports, only a dllmain entry which spawns one thread and returns. the main module maintains multiple binary resources that include executable, configurations, and encryption data: values 104 111 are encrypted with the rsa private key (resource 101) and compressed with bzip2.4. the rsa key is stored with header stripped in a format similar to microsoft s pvk; the rsa private key header is appended by the loader before reading the keys into the encryption code. resource 109 points to a registry location called external storage , built-in resources are called pe storage . in addition to storing code, crypto resources, and configuration data in pe resources, whitebear copies much of this data to the victim host s registry. registry storage is located in the following keys. subkeys and stored values listed below:
[hkcusoftwaremicrosoftwindowscurrentversionexplorerscreensaver] [hkcusoftwaremicrosoftwindows ntcurrentversionexplorerscreensaver]
finally, if the main whitebear module fails to use registry storage, it uses fs storage in file %temp% . the module reads all of its data and binary components from one of the storages and then verifies the integrity of data (rsa+bzip2 compression+signature). the module maintains functionality which is divided into a set of subsystems that are loosely named by the developers: result queue task queue message processing system autorun manager execution subsystem inject manager pestorage local transport manager/internal transport channel it creates the following temporary files: every day (as specified by local time) the main module restarts the transport subsystem which includes: message processing named pipe transport ( nptransport ) if the registry/file storage is empty, the module performs a migration of hardcoded modules and settings to the storage location. this data is encrypted with a new rsa key (which is also stored in the registry). the data in the registry is prepended with a 0xc byte header. the maximum size of each registry item is 921,600 bytes; if the maximum size is exceeded, it is split into several items. the format of the header is shown below:
[4:service dword][4:chunk index][4:chunk size including header] every time the orchestrator module is loaded it validates that the storage area contains the appropriate data and that all of the components can be decrypted and validated. if these checks fail the module reinstalls a configuration from the resource reinstall . pipe transport
the module generates the pipe name (with the same prefix as the loader); waits for incoming connections; receives data and pushes it to the message processing system . the module generates the pipe name (with the same prefix as the loader); waits for incoming connections; receives data and pushes it to the message processing system . every packet is expected to be at least 6 bytes and contain the following header: [4:id][2:command]
depending on the command, the module returns the results from previously run tasks, the configuration of the module, or a confirmation message. an example of these tasks is shown below: write a file and execute it with createprocess() capturing all of the standard output update c&c configuration, plugin storage, etc update autoruns write arbitrary files to the filesystem ( file upload ) read arbitrary files from the filesystem ( file download ) update itself uninstall push task results to c2 servers the localtransport manager handles named pipe communication and identifies if the packet received is designated to the current instance or to someone else (down the route). in the latter scenario the localtansport manager re-encrypts the packet, serializes it (again), and pushes the packet via a named pipe on the local network to another hop, (nullsessionpipes). this effectively makes each infected node a packet router. the autorun manager subsystem is responsible for tracking the way that the malicious module starts in the system and it maintains several different methods for starting automatically (shown below):
linkautorun the subsystem searches for a lnk file in the target directory, changes the path to and the description to /q /c start %s && start %s taskscheduler20autorun the subsystem creates the itaskservice (works only on windows vista+) and uses the itaskservice interface to create a new task with a logon trigger
startupautorun the subsystem creates a lnk file in %startup%
screensaverautorun the subsystem installs as a current screensaver with a hidden window
hiddentaskautorun the subsystem creates the task itaskscheduler (works only on pre-vista nt). the task trigger start date is set to the creation date of the windows directory
shellautorun winlogon registry [hkcusoftwaremicrosoftwindows ntcurrentversionwinlogon] shell= , file uninstallation is done in a discreet manner. the file is filled with zeroes, then renamed to a temporary filename before being deleted this transport library does not appear on disk in its pe format. it is maintained as encrypted resource 107 in the orchestrator module, then decrypted and loaded by the orchestrator directly into the memory of the target process. this c2 interaction module is independent, once started, it interacts with the orchestrator using its local named pipe. to communicate with its c2 server, the transport library uses the system user agent or default mozilla/4.0 (compatible; msie 6.0) . before attempting a connection with its configured c2 server, the module checks if the victim system is connected to internet by sending http 1.1 get / requests to the following servers (this process stops after the first successful connection):
if there is no internet connection available, the module changes state to, cannot_work and notifies the peer by sending command 7 over the local pipe. the c2 configuration is obtained from the main module with the command 5 . this checks whether the module complies with the schedule specified in the c2 settings (which includes inactivity time and the interval between connections). the c2 interaction stages have interesting function names and an odd misspelling, indicating that the developer may not be a native english speaker (or may have learned the english language in a british setting):
the module writes the encrypted log to %temp% .cvr the module sends a http 1.0 get request through a randomly generated path to the c2 server. the server s reply is expected to have its md5 checksum appended to the packet. if c2 interaction fails, the module sends the command 10 ( no_connect_to_gayzer ) to the orchestrator. unusual whitebear encryption
the encryption implemented in the whitebear orchestrator is particularly interesting. we note that the resource section is encrypted/decrypted and packed/decompressed with rsa+3des+bzip2. this implementation is unique and includes the format of the private key as stored in the resource section. 3des is present in sofacy and duqu2 components, however they are missing in this microsoft-centric rsa encryption technique. the private key format used in this schema and rsa crypto combination with 3des is (currently) unique to this threat actor. the private key itself is stored as a raw binary blob, in a format similar to the one microsoft code uses in pvk format. this format is not officially documented, but its structures and handling are coded into openssl. this private key value is stored in the orchestrator resources without valid headers. the orchestrator code prepends valid headers and passes the results to openssl functions that parse the blob. digital code-signing certificate fictional corporation or assumed identity?
most whitebear samples are signed with a valid code signing certificate issued for solid loop ltd , a once-registered british organization. solid loop is likely a phony front organization or a defunct organization and actors assumed its identity to abuse the name and trust, in order to attain deceptive code-signing digital certificates. whitebear command and control
the whitebear c2 servers are consistent with long standing turla infrastructure management practices, so the backdoors callback to a mix of compromised servers and hijacked destination satellite ip hosts. for example, direct, hardcoded turla satellite ip c2 addresses are shown below: targeting and victims
whitebear targets over the course of a couple years are related to government foreign affairs, international organizations, and later, defense organizations. the geolocation of the incidents are below: europe
south asia
central asia
east asia
south america
conclusions
whitebear activity reliant on this toolset seems to have diminished in june 2017. but turla efforts continue to be run as multiple subgroups and campaigns. this one started targeting diplomatic entities and later included defense related organizations. infrastructure overlap with other turla campaigns, code artifacts, and targeting are consistent with past turla efforts. with this subset of 2016-2017 whitebear activity, turla continues to be one of the most prolific, longstanding, and advanced apt we have researched, and continues to be the subject of much of our research. links to publicly reported research are below. reference set
full ioc and powerful yara rules delivered with private report subscription
references past turla research
the epic turla operation
satellite turla: apt command and control in the sky
agent.btz: a source of inspiration?
the penquin turla
penquin s moonlit maze
kopiluwak: a new javascript payload from turla
