en route with sednit part 2: observing the comings and goings version 1.0 october 2016 table of content executive summary
introduction the sednit group
the second part of the trilogy
attribution
publication strategy xagent: backdoor specially compiled for you identikit
timeline
context
initialization
modules
communication channels
conclusion and open questions sedreco: the flexible backdoor identikit
context
dropper workflow
payload workflow
conclusion and open questions xtunnel: reaching unreachable machines identikit
timeline
big picture
traffic proxying
additional features
conclusion and open questions closing remarks
indicators of compromise xagent
sedreco
xtunnel xagent version 2 linux modules
agentkernel accepted commands
xagent version 2 linux channels
sedreco payload commands
xtunnel parameters imeline of 0-day vulnerabilities exploited by the sednit group in 2015.
main attack methods and malware used by the sednit group since 2014,
and how they are related
xagent major events
partial directory listing of xagent source files
xagent communication workflow
cryptrawpacket data buffer format
url for get and post requests, x.x.x.x being the c&c server ip address
format of the token value
proxy server source files
communication workflow between an xagent infected computer using
mailchannel and its c&c server, via a proxy server
email subject generated by the p2 protocol.
dropper workflow with the developers names for each step
extract of sedreco configuration. the names of the fields are those created
by eset s analysts. field sizes are in bytes.
command registration cmd functions are the commands handlers
data flow between sedreco on a compromised host and its c&c server
network contact message format. computer name is a variably-sized field
inbound file format. field sizes are in bytes
outbound file format. field sizes are in bytes
extract of lzw algorithm c source code
plugin init export
plugin uninit export
xtunnel major events
xtunnel core behavior
xtunnel communication workflow
extract of t initialization code xtunnel cfg before obfuscation
xtunnel cfg after obfuscation
executive summary
the sednit group also known as apt28, fancy bear and sofacy is a group of attackers
operating since 2004 if not earlier and whose main objective is to steal confidential information
from specific targets.
this is the second part of our whitepaper en route with sednit , which covers the sednit s group
activities since 2014. here, we focus on sednit s espionage toolkit, which is deployed on targets
deemed interesting after a reconnaissance phase (described in the first part of the whitepaper).
the key points described in this second installment are the following: the sednit group developed two different spying backdoors for long term monitoring, named sedreco and xagent, in order to maximize the chance of avoiding detection the xagent backdoor can communicate with its c&c server over email with a custom protocol, which in some cases is based on georgian words the sednit group developed a network proxy tool, named xtunnel, to effectively transform a compromised computer into a network pivot, in order to contact machines that are normally
unreachable from the internet the xagent source code, the xagent c&c server configuration, and the xtunnel binaries
all contain traces of russian, strongly reinforcing the hypothesis that this is the language
employed by the sednit group s members for any inquiries related to this whitepaper, contact us at: threatintel@ en route with sednit introduction
readers who have already read the first part of our sednit trilogy might want to skip the following section
(duplicated from the previous part) and go directly to the specific introduction of this second part. the sednit group
the sednit group variously also known as apt28, fancy bear, sofacy, pawn storm, strontium
and tsar team is a group of attackers operating since 2004 if not earlier, whose main objective
is to steal confidential information from specific targets. over the past two years, this group s activity
has increased significantly, with numerous attacks against government departments and embassies
all over the world.
among their most notable presumed targets are the american democratic national committee [1],
the german parliament [2] and the french television network tv5monde [3]. moreover, the sednit
group has a special interest in eastern europe, where it regularly targets individuals and organizations
involved in geopolitics.
one of the striking characteristics of the sednit group is its ability to come up with brand-new 0-day [4]
vulnerabilities regularly. in 2015, the group exploited no fewer than six 0-day vulnerabilities, as shown
in figure 1. timeline of 0-day vulnerabilities exploited by the sednit group in 2015 this high number of 0-day exploits suggests significant resources available to the sednit group, either
because the group members have the skills and time to find and weaponize these vulnerabilities,
or because they have the budget to purchase the exploits.
also, over the years the sednit group has developed a large software ecosystem to perform
its espionage activities. the diversity of this ecosystem is quite remarkable; it includes dozens
of custom programs, with many of them being technically advanced, like the xagent and sedreco
modular backdoors (described in the second part of this whitepaper), or the downdelph bootkit
and rootkit (described in the third part of this whitepaper).
we present the results of eset s two-year pursuit of the sednit group, during which we uncovered
and analyzed many of their operations. we split our publication into three independent parts:
1. part 1: approaching the target describes the kinds of targets the sednit group is after,
and the methods used to attack them. it also contains a detailed analysis of the group s
most-used reconnaissance malware. 46 en route with sednit 2. 3. part 2: observing the comings and goings describes the espionage toolkit deployed on some
target computers, plus a custom network tool used to pivot within the compromised
organizations. part 3: a mysterious downloader describes a surprising operation run by the sednit group,
during which a lightweight delphi downloader was deployed with advanced persistence
methods, including both a bootkit and a rootkit. each of these parts comes with the related indicators of compromise. the second part of the trilogy
figure 2 shows the main components that the sednit group has used over the last two years,
with their interrelationships. it should not be considered as a complete representation of their
arsenal, which also includes numerous small custom tools.
and how they are related we divide sednit s software into three categories: the first-stage software serves for reconnaissance
of a newly compromised host, then comes the second-stage software intended to spy on machines
deemed interesting, while the pivot software finally allows the operators to reach other computers.
in this second part, we focus on sednit s espionage toolkit, which serves for long term monitoring
of compromised computers. the components described in this second part are outlined in blue
in figure 2, which includes the two spying backdoors sedreco and xagent, and the network
tool xtunnel.
the usual workflow of sednit s operators is to deploy both sedreco and xagent on a newly-
compromised computer, after a reconnaissance phase with first-stage malware (seduploader,
described in the first part of this whitepaper, or downdelph, described in the third part). deploying
both spying backdoors at the same time allows them to remain in contact if one of them becomes
detected. the network tool xtunnel comes later, in order to reach other accessible computers. en route with sedniten route with sednitpart (cid:26)en route with sednitpart (cid:26) all the components shown in figure 2 are described in this whitepaper,
with the exception of usbstealer, a tool to exfiltrate data from air-gapped
machines that we have already described at welivesecurity [5]. recent
versions have been documented by kaspersky labs [6] as well. readers who have already read the first part of our sednit trilogy may skip the following sections
and go directly to xagent s analysis. attribution
one might expect this reference whitepaper to add new information about attribution. a lot has
been said to link the sednit group to some russian entities [7], and we do not intend to add anything
to this discussion.
performing attribution in a serious, scientific manner is a hard problem that is out of scope
of eset s mission. as security researchers, what we call the sednit group is merely a set of software
and the related network infrastructure, which we can hardly correlate with any specific organization.
nevertheless, our intensive investigation of the sednit group has allowed us to collect numerous
indicators of the language spoken by its developers and operators, as well as their areas of interest,
as we will explain in this whitepaper. publication strategy
before entering the core content of this whitepaper, we would like to discuss our publication strategy.
indeed, as security researchers, two questions we always find difficult to answer when we write
about an espionage group are when to publish? , and how to make our publication useful to those tasked
with defending against such attacks? .
there were several detailed reports on the sednit group published in 2014, like the operation pawn
storm report from trend micro [8] and the apt28 report from fireeye [9]. but since then the public
information regarding this group has mainly came in the form of blog posts describing specific
components or attacks. in other words, no public attempts have been made to present the big
picture on the sednit group since 2014.
meanwhile, the sednit group s activity has significantly increased, and its arsenal differs from those
described in previous whitepapers.
therefore, our intention here is to provide a detailed picture of the sednit group s activities over
the past two years. of course, we have only partial visibility into those activities, but we believe
that we possess enough information to draw a representative picture, which should in particular
help defenders to handle sednit compromises.
we tried to follow a few principles in order to make our whitepaper useful to the various types
of readers: keep it readable: while we provide detailed technical descriptions, we have tried to make them readable, without sacrificing precision. for this reason we decided to split
our whitepaper into three independent parts, in order to make such a large amount of
information easily digestible. we also have refrained from mixing indicators of compromise
with the text. help the defenders: we provide indicators of compromise (ioc) to help detect current sednit infections, and we group them in the ioc section and on eset s github account [10]. hence,
the reader interested only in these iocs can go straight to them, and find more context
in the whitepaper afterwards. en route with sednit reference previous work: a high profile group such as sednit is tracked by numerous entities. as with any research work, our investigation stands on the shoulders of the previous
publications. we have referenced them appropriately, to the best of our knowledge. document also what we do not understand: we still have numerous open questions
regarding sednit, and we highlight them in our text. we hope this will encourage fellow
malware researchers to help complete the puzzle. we did our best to follow these principles, but there may be cases where we missed our aim.
we encourage readers to provide feedback at threatintel@ , and we will update
the whitepaper accordingly. en route with sednit xagent: backdoor specially compiled for you identikit
xagent is a modular backdoor with spying functionalities
such as keystroke logging and file exfiltration. alternative names
splm, chopstick usage
xagent is the flagship backdoor of the sednit group, deployed
by them in many of their operations over the past two years.
it is usually dropped on targets deemed interesting by the operators
after a reconnaissance phase, but it has also been used as first-stage
malware in a few cases. known period of activity
november 2012 to august 2016 (the time of this writing). probably
still in use. known deployment methods downloaded by downdelph downloaded by sedkit dropped by seduploader dropper downloaded by seduploader payload distinguishing characteristics xagent is developed in c++ with a modular architecture, around a core module named agentkernel xagent has been compiled for windows, linux and ios (at least) xagent possesses two different implementations of its c&c
communication channel, one over http and the other over
emails (smtp/pop3 protocols) xagent binaries are often compiled for specific targets, with a special choice of modules and communication channels 50 en route with sednit timeline
the dates posited in the timeline mainly rely on xagent compilation timestamps, which we believe
have not been tampered with because they match up with our telemetry data. these dates may
be later than the actual events though, as we do not have all xagent samples, but enough
are present to give a good approximation. in particular, we dated the appearance of xagent
as independent malware in november 2012, but fellow malware researchers reported to us privately
that parts of its code were used before that.
introduction of xagent
version 1 for windows introduction of xagent
version 2 for both linux
and windows xagent deployed
with sedkit exploit kit introduction of xagent
version 3 for windows;
modules now have
obfuscated run-time type
information (rtti) .
[12] xagent found on
the servers of the
democratic national
committee (dnc) introduction of xagent
version 3 for linux xagent for ios found
by trend micro figure 3. xagent major events 51 en route with sednit context
during our investigations, we were able to retrieve the complete xagent source code for the linux
operating system. to the best of our knowledge, this is the first time this xagent source code
has been found and documented by security researchers.
this source code is a fully working c++ project, which was used by sednit operators to compile
a binary in july 2015 (at least). the project contains around 18,000 lines of code among 59 classes;
a partial directory listing of the source files is shown in figure 4. partial directory listing of xagent source files en route with sednit we believe the linux source code is derived from the windows version of xagent. in other words,
os-specific operations have been re-implemented, but the core logic remains the same on both
platforms. as an example of this lineage, the following code snippet shows some windows api calls
for thread termination commented out by the developers, and replaced with a call to the linux
pthreads [14] interface. according to its internal version numbering, this source code is version 2 of xagent, while currently
distributed windows and linux binaries are version 3. nevertheless, there appear to be only minor
differences between the two versions, and the source code matches the core logic of the most recent
samples on both windows and linux platforms. also, the ios version of xagent found by trend
micro [13] not documented in this white paper is based on this source code, according
to our own analysis.
therefore, we decided to present an analysis of xagent mainly based on the source code,
and not on binaries, to ease the explanations.
in order to facilitate the reading of the source code, we made the following syntactic choices: parts of the code not relevant to our analysis have been replaced by [ ] as the code is heavily commented by its developers, we decided to leave those comments untouched. for the reader this comes at the price of enduring poorly-worded english
comments, but this allows a finer understanding of what the developers were thinking. our own comments on the code appear after the snippets, and are indicated by numbered tags when the developers comments are in russian, we added the translation in the form of /* translates to: */ en route with sednit initialization
we begin our journey through xagent source code in the file in the function
startxagent(), which contains the instantiations of the main objects, as shown below.
nstantiation of an agentkernel object, called kernel hereafter, which is the xagent execution manager. instantiation of an iagentchannel object, called channel hereafter, which is the means of communication with the c&c server. the source code contains two different channel
implementations, one over http and one over email. here the developers have commented
out the email channel instantiation. instantiations of several iagentmodule objects, called modules hereafter, which implement xagent functionalities. here the developers have commented out the keylogger
module instantiation. calls to the agentkernel::registerchannel() and agentkernel::registermodule()
methods, through which the kernel starts managing these modules executions, and pass
their communications through the registered channel. registrations of the unused channel
and module are commented out. call to the agentkernel::startwork() method, which creates execution threads on the worker methods of each registered module and channel. commenting out module and channel instantiations is a strategy we previously observed when
analyzing xagent binaries. each sample does indeed come with a specific combination of modules
and channels, even though the xagent kernel is completely capable of managing all of them
in parallel (including multiple channels).
by doing so, operators probably intend to adapt xagent binaries for specific targets, and avoid
exposing the whole xagent code to security researchers. moreover, operators may still deploy
additional modules and channels during execution, as we will explain later. en route with sednit modules
the core xagent functionalities lie in its modules. as shown in the startxagent() snippet,
xagent linux source code contains three modules, plus the kernel which is itself also a module.
these modules are listed in table 1: provides wrappers for file system
operations (find, read, write, execute, etc) executes supplied commands in linux
command-line interpreter /bin/sh moduleremotekeylogger modulefilesystem processretranslatormodule as shown in the second column, each module is identified by a 2-byte id, which is a combination
of a version number and a module identifier. for example, when agentkernel id is set to 0x0002,
it corresponds to version 2 and the module numbered 0. currently distributed xagent binaries possess a kernel id of 0x3303,
thus corresponding to kernel version 3 and the module strangely num-
bered 33. the oldest xagent versions had a kernel id of 0x0001. each linux xagent module has an equivalent module in the windows version, as shown in the fourth
column of table 1 (windows names come from run-time type information (rtti) [12] left in some
binaries). due to operating system peculiarities, the module implementations differ between
windows and linux, but their ids and the commands they accept are the same.
in the following section, we will present an in-depth description of the kernel module, leaving aside
the other, more straightforward, modules. while recent versions of xagent for windows only have the modules
described in table 1, older versions have been seen with additional modules,
such as: directoryobservermodule, which monitors all mounted volumes for files modulenetflash, which monitors removable drives for c&c messages, in a similar way to usbstealer [5] modulenetwatcher, which maps network resources en route with sednit kernel
as described in table 1, agentkernel is the execution manager, and the only module
that has to be present in all xagent binaries. constructor
our analysis of agentkernel begins in its constructor: instantiation of a localstorage object, which is the kernel store. it contains both
a file-based storage for the communications with the c&c server, and an sqlite3 [15]
database to store various configuration parameters. instantiation of a cryptor object, which is the cryptographic engine of the kernel. it will serve in particular to encrypt the communications with the c&c server. instantiation of a channelcontroller object, which is the interface to contact the c&c server, as we will explain later. instantiation of a reservedapi object. it implements some helper functions used by the kernel,
like reservedapi::initagentid() to generate a 4-byte id for the xagent infected computer. the kernel being a module, it inserts itself in the list of modules whose execution will be managed. in the kernel constructor code and elsewhere, important strings are accessed through a class
named coder, which is a wrapper around an encrypted string. the string is then decrypted on-demand
by an exclusive-or (xor) with a key defined at the time the coder object was instantiated. en route with sednit for example, in the following code snippet kernel_path_main_key is the encrypted string
and mask the key, while the decrypted string is then retrieved by calling the method this mechanism theoretically allows xagent to keep strings encrypted until they are used.
nevertheless, a macro in the source code allows them to be left unencrypted (the key in coder
being forced to zeros), which is actually the case in all linux binaries we analyzed. on the other
hand, the coder class is indeed used with encrypted strings in windows xagent. the kernel constructor code refers to some configuration parameters whose
values are hardcoded in the header file . the definitions
of these parameters appear to have been automatically extracted from
a xml file, as shown for example below for the xagent mutex name. en route with sednit core logic
as for all modules, the core logic of the kernel lies in its run() method, on which an execution thread
has been created by the previously described startwork() method. the purpose of the kernel run()
method is to relay the communications between the modules and the c&c server, as shown in figure 5,
and as described below. eports to c&c server the list of installed modules fetches messages from modules for the c&c server fetches messages en route with sednitlegendmodules hello message
first things first, agentkernel::run() reports the list of installed modules to the c&c server.
more precisely, the kernel behaves as if it had received a command called ping_request from
the c&c server (the kernel s commands will be described in the following section). it then builds
a report in a modulemsg object, which is the class encapsulating messages to or from modules,
and whose important fields are shown in the following code snippet.
in this report message the modid field is set to the kernel id 0x0002, cmdid to ping_request,
and data points to the list of installed module ids separated by the character #.
the modulemsg object is then passed to the agentkernel::translatetocontroller() method,
which takes charge of its encryption, resulting in a cryptrawpacket object. this object just contains
a pointer to a buffer whose format is described in figure 6.
the buffer starts with a header composed of the agent id and a checksum calculated on the rest
of the data. this checksum is a 2-byte cyclic redundancy check (crc) [16] calculated on the data
with a 2-byte pseudo-randomly generated polynomial. these two values are appended to each other
to form the checksum field 4-byte value. rc4-encrypted. the data_token value is hardcoded in the source code and probably serves to check
the integrity of the message during decryption by the c&c server. the key used for rc4-encryption
is the concatenation of a hardcoded 50-byte value and a pseudo-randomly generated 4-byte value,
named register and appended to the encrypted data. the exact same 50-byte value is used to form an rc4-key, also with
a register , in downdelph and seduploader. as shown in figure 5, the resulting buffer is written into a file maintained by the localstorage
object. the encrypted data are then retrieved from this file and sent to the c&c server
by the channelcontroller::senddatatoserver() method, through the currently selected
channel (channel implementation will be described in the next section). communications loop
as shown in figure 5, agentkernel::run() then enters in an infinite loop relaying communications
between the modules and the c&c server: it fetches modulemsg objects from the modules, which are then transmitted to the c&c server
by the process previously described for the initial report. for example, the remotekeylogger
module regularly sends a message containing the captured keystrokes to the c&c server. it retrieves cryptrawpacket objects sent by the c&c server from a c++ vector dubbed _get_
questions and filled by the channelcontroller::getdatafromserver() method. those
objects are decrypted and deserialized into modulemsg objects, which are then transmitted
to the intended module. for example, the c&c server can send a message with the command
start for the remotekeylogger module, which then begins its keylogging activity. accepted commands
the kernel accepts 12 different commands from the c&c server, as listed in table 2. in practice these
commands are integer values corresponding to macros defined in the source code.
reports ids and settings of modules and channels to the c&c server reports ids of modules to the c&c server sets the parameter defining the amount of time to wait before initially
contacting the c&c server to the given value sets the parameter defining the amount of time to wait between
two attempts to reach the c&c server to the given value saves the two previous parameters current values into the localstorage
sqlite3 database, such that those values will be re-used at next startup changes the currently selected channel to the channel identified
by the given id (see next section for details on the channels) changes the settings of the channel identified by the given id.
for example, it may be used to change the c&c server address. instantiates an iagentmodule object from the given data, and
registers this new module with the kernel unloads the module identified by the given id instantiates an iagentchannel object from the given data,
and registers this new channel with the kernel unloads the channel identified by the given id kills the xagent process (no uninstallation procedure implemented) communication channels
the channelcontroller object is in charge of contacting the c&c server through the currently
selected communication channel, as shown in figure 5. this controller is unaware of the underlying
implementation of the channel, and can use for that purpose any object implementing the abstract
class named iagentchannel.
the linux source code contains two channels, one using http and one using emails, as described
in table 3. each channel is identified by a 2-byte id similar to the previously described module id. there exists
an implementation for the http-based channel on windows, while we only found a channel to send
emails, without the ability to receive emails, on this platform.
by implementing the iagentchannel abstract class, the channels provide a getrawpacket()
method to fetch a message from the c&c server, and a sendrawpacket() method to send
a message to the c&c server. as previously explained, those messages are cryptrawpacket objects.
we describe in this section the implementations of these methods for the two linux channels. while xagent samples usually come with only one channel, the channel-
controller object can manage several of them in parallel. in particular it
will automatically switch to a different channel if there is one in case the
currently selected one is broken, as shown in figure 5. additionally, the oper-
ators can deploy a completely new channel through the previously described
load_new_channel kernel command. en route with sednit httpchannel
the httpchannel::getrawpacket() method is implemented as a http get request the message
from the server being then in the http answer body while httpchannel::sendrawpacket()
is an http post request, whose body contains the message. the c&c ip address is hardcoded
in the associated header file .
both get and post requests are done on a url following the format pictured in figure 7.
oughly summarized, this url is a series of pseudo-randomly chosen parameters associated
with pseudo-randomly generated values, except for a special parameter called mark. this special
parameter (whose value is set to ai in the linux source code) is associated with a so-called token,
which is a 20-byte value encoding the agent id in the format pictured in figure 8.
format of the token value in this token, the key is pseudo-randomly generated, while url_token is hardcoded in the source
code and probably serves to check the integrity of the message by the c&c server.
the bodies of the post requests, and of the responses to get requests, follow exactly the same
format as the token, except that they contain a cryptrawpacket object in place of the agent id.
also, the hardcoded value is a different one, called data_token by the developers. mailchannel
the mailchannel object is an implementation of xagent communication channel over emails,
where messages are sent and received as attachments to emails.
during an investigation, we discovered the source code of a proxy server employed to relay traffic
between xagent infected computers using mailchannel (dubbed agents hereafter) and a c&c server.
this source code was left in an open directory on the proxy server, which was then indexed
by the google search engine.
proxy server source files as can be seen from the files names, the proxy is actually more than a simple relay of communications:
it translates the email channel protocol from the agents into http requests for the c&c server.
therefore, we decided to include this proxy in our analysis of the email communication channel.
figure 10 represents the whole communication workflow that will be described in this section.
en route with sednitstorage foldersfor agent (cid:22)(cid:21)(cid:20)(cid:19)(cid:21)(cid:20)(cid:19)p(cid:30)scheme(cid:31) level (cid:24) protocol (cid:18)legendp(cid:30)scheme(cid:31) level (cid:24) protocol (cid:18) the proxy source code contains a few unused instructions related to agents
communicating over http, i.e. using httpchannel rather than mailchan-
nel. nevertheless, the main class responsible for relaying http traffic
from agents named w3server is absent and its instantiation has been
commented out. similar to xagent, the operators therefore seem to deploy
the components of the proxy server only if needed, and this one was intended
to relay mailchannel traffic only. on the agent
the mailchannel::sendrawpacket() method is in charge of sending cryptrawpacket objects
as email attachments. for that purpose, the code contains an smtp server address with an email
address and a password to log in, plus a recipient email address to which the emails will be sent.
depending on the sample, this recipient email address may belong to a freemail provider, a custom
sednit domain, or even a hacked target.
building a c&c protocol over email brings at least two problems for the operators: they need
to be able to distinguish xagent emails from unrelated emails in the inbox (like spam emails),
and they need to bypass spam filters. to do so, they implemented a protocol named p2scheme
(and dubbed p2 hereafter), which defines the format of the emails. this protocol is described
as a level 2 protocol by the developers, and defines the following email fields: the email subject is the base64 encoding of a value following the format pictured in figure 11. figure 11. email subject generated by the p2 protocol. in this format, the key is pseudo-randomly generated, while subj_token is a 7-byte value
hardcoded in the source code and strangely containing the string china (prefixed with bytes 0x55
0xaa). this specific subject serves to distinguish xagent emails from unrelated emails in an inbox,
as we will explain. the email body and the attachment name are the base64 encodings of pseudo-randomly generated values. the boundary value, used to separate a mime multipart message in parts [17], is a pseudo- randomly generated value. nevertheless, in practice only the boundary is actually generated with the p2 protocol, as the code
to generate the others fields has been commented out in the linux source code. instead, these fields
are set to fixed values, likely chosen to avoid attracting attention from georgian targets: the email subject is set to piradi nomeri, which refers to a national id number in georgian the email body is set to gamarjoba, which means hello in georgian the attachment name is set to , where x is the current time (detaluri
georgian institutions are well-known targets of the sednit group,
as documented by fireeye in 2014 [9]. once the email has been built, the cryptrawpacket object is added as an attachment. finally,
the email is sent with the smtp protocol over tls to the recipient email address (exfil@ in figure 10). it will be retrieved by the proxy server, and the message will be forwarded
to the c&c server, as we will describe below.
in the other direction, the mailchannel::getrawpacket() method retrieves emails containing
messages from the c&c server with the pop3 protocol over tls. the email address to receive messages
is a different one than the one used to send messages (orders@ in figure 10). for each
received email, the method checks that the subject is set to piradi nomeri and, if so, instantiates
a cryptrawpacket object from the attachment, which is then transmitted to the intended module. on the proxy server
the script manages the communications by emails with the agents. to do so,
it regularly fetches emails from the inbox agents have sent their messages to (exfil@ in figure 10).
the script then checks for each email whether the subject matches the p2 protocol; that is, if once
decoded it contains the subj_token value (see figure 11). alternatively, it checks whether the subject
is set to piradi nomeri, which is the case with the linux source code as we just explained.
if the subject is valid, stores the email attachment into a from folder associated
with the sender agent, using a custom format defined in a class named p3scheme. this format, dubbed level 3 protocol , is a variation of the one presented in figure 8 for the http token: namely,
the length of junk is set to 9 and the hardcoded value is different. the script manages a storage with a from and to folder for each agent that sent an email to the monitored inbox (the agent id
being retrieved from the cryptrawpacket attached to the email). the second important script is , which manages the http communications with the c&c server.
for all known agents, the script retrieves the messages dropped in the from folder, and sends them
to the c&c server in the body of a http post request. the url for this request is built by the following
python code: the values xas_ip and xas_gate are respectively the c&c server address and url path,
while server_uid is a 4-byte value identifying the proxy server. the p3_scheme.pack_service_
data() method encodes data following the previously-described p3 format. en route with sednit in the other direction, the script regularly sends a http get request to the c&c server,
on the url previously described, for all known agents. the body of the c&c answer is a message
encoded with the p3 protocol that will be stored in the to folder. then, the script
will retrieve the message and attach it to an email following the p2 protocol, which will be sent
to the agent. from the log files contained in the proxy open folder, we can infer that it was
a windows server configured in the russian language (python console error
messages were output in russian language). conclusion and open questions
xagent is a well-designed backdoor that has become the flagship espionage malware of the sednit
group over the past few years. the ability to communicate over http or via emails make it a versatile
tool for the operators.
moreover, the existence of xagent versions for windows, linux and ios shows the importance
of this backdoor in their arsenal. we speculate that there are versions for others platforms, like android. en route with sednit sedreco: the flexible backdoor identikit
sedreco serves as a spying backdoor, whose functionalities
can be extended with dynamically loaded plugins. it is made
up of two distinct components: a dropper and the persistent
payload installed by this dropper. alternative names
azzy usage
sedreco is deployed on targets deemed interesting after
a reconnaissance phase. it serves for long-term espionage,
thanks to the numerous commands provided by its payload. known period of activity
may 2012 to july 2016. probably still in use at the time of writing
(august 2016). known deployment methods downloaded by seduploader downloaded by downdelph distinguishing characteristics the sedreco payload relies on a configuration usually stored in a registry key named path, or in a file named msd, and initially
embedded in the sedreco dropper the sedreco payload creates a mutex named mutyzaz or azzymtx the inbound and outbound communications of sedreco s payload with its c&c server are buffered into two files,
respectively named and en route with sednit context
sedreco has two binary components, a dropper and the spying backdoor usually contained
in this dropper. the dropper part of sedreco has also been used to deploy a different payload:
a lightweight downloader (not described in this whitepaper) named by its developers.
we believe sedreco was first used in 2012, while our analysis was performed on samples
compiled mid-2016. dropper workflow
the workflow of sedreco s dropper is composed of the five steps presented in figure 12.
while straightforward, this workflow possesses some features worth mentioning: the payload configuration is installed on the system by the dropper, in a file or in a registry
key, depending on the sample. it means that analyzing a sedreco payload sample itself will
not reveal configuration information, such as the c&c server address (configuration content
will be described below). payload persistence is usually ensured by registering an auto-start entry in the windows
registry, but we have observed other methods, like registering the payload as a shell icon
overlay handler com object [18]. during its execution the dropper builds a small report, which is then sent to the c&c server. here is an example of such a report: each line corresponds to one step of the dropper workflow, as described in figure 12.
the value 0 means success, while there would be an error code returned from the windows api
getlasterror otherwise. en route with sednit payload workflow
in this section we will describe the internal working of the sedreco payload: first, its configuration
file format; second, the commands it can execute; then, how it communicates with its c&c server;
and finally, how its functionality can be extended with plugins. configuration
the first action of sedreco s payload is to retrieve the configuration file previously installed
by the dropper. this configuration file consists of a series of variably-sized data fields, preceded
by a header, as described in figure 13. extract of sedreco configuration. the names of the fields are those created
by eset s analysts. field sizes are in bytes. the configuration is encrypted with a custom algorithm using a 6-byte key stored at its beginning.
an implementation of this algorithm in python can be found in eset s github repository [10].
following the key come 10 1-byte fields, each of them containing the size of a corresponding
data field. those data fields contain the following values (eset s names):
1. timer1: time to wait between two attempts to ask the c&c server for a command to execute (usually set to 10 minutes) 2. timer2: time to wait between two attempts to exfiltrate data to the c&c server (usually set to 10 minutes) 3. computer name: computer name to which a pseudo-randomly generated 6-byte value is appended, plus a two-byte value hardcoded in the dropper 4. c&c1: domain name of the first c&c server
5. c&c2: domain name of the second c&c server
6. operation name: 4-character string initially hardcoded in the dropper, which likely identifies the operation or the target. so far, we have observed the following values: rhze,
rhdn, rhst, rhbp, mtfs, mctf, mtqs. we do not know the exact meaning of these values.
7. keylogger maxbuffer: maximum size of the memory buffer where keystrokes are logged, before they are dumped to the outbound file (described below) 8. keylogger maxtimeout: maximum time to wait before the logged keystrokes are dumped to the outbound file (described below) 9. keylogger flag: specify whether to enable the keylogger or not
10. c&c3: domain name of the third c&c server 70 are initially empty, and are updated when sedreco receives a plugin to load from the c&c server. commands
once it is running, sedreco provides numerous commands to its operators, identified by a number,
as described in table 4. those commands allow the attackers to spy on the target, but also to collect
information on other computers accessible from the compromised machine. en route with sednit this mechanism makes sedreco a flexible backdoor, which includes only the commands in a sample
that are currently needed (which means in particular that the previous list of commands may
not be complete). it also allows plugins to easily register new commands, as we will explain later. communications with the c&c server
sedreco communicates with its c&c server in a quite unusual way, pictured in figure 15.
on one hand, sedreco network threads periodically ask the c&c server for orders, and store them
in an inbound file . those orders are then fetched and processed by sedreco core threads. on the other
hand, the data to exfiltrate (logged keystrokes, results of executed commands, etc) are queued
in an outbound file , and periodically transmitted in bulk to the server by the network threads.
as this asynchronous communication method limits the number of network contacts with the
c&c server, it might reduce the chance of attracting attention in the target s network. moreover,
using files rather than keeping the data buffered in memory avoids losing the data if the machine
shuts down or loses network connectivity.
in the following sections, we describe the network communications and the exact format
of the inbound/outbound files. inbound communications
sedreco regularly asks its c&c server for a command to run usually every 10 minutes. the c&c server
domain names are retrieved from the configuration, and they are contacted in their order of appearance
in this configuration (see configuration format). in other words, if the first c&c server is up c&c1
in figure 13 the others are never contacted.
the actual contact is a post request over http or, depending of the sample, https, on the uri
/update. the body of the request contains the base64-encoding of the data structure pictured
in figure 16.
en route with sednitcompromised computer(cid:31)(cid:31)(cid:31)n(cid:30)(cid:29)(cid:28)n(cid:30)(cid:29)(cid:28)n(cid:30)(cid:29)nlegend this data structure is encrypted with the 6-byte key stored at the end, using the same algorithm
as that used to encrypt the configuration file. the type field is set to 0, which distinguishes inbound
from outbound.
the c&c server will then answer with the information about a command to run, the commands
being stored in the inbound file by sedreco network threads. the inbound file is usually named and located in the %temp% directory. this file consists of a series of variably-sized
entries, each entry containing the information from the c&c server for one command to run,
as described in figure 17. plain text data encrypted text data as before, each entry starts with a 6-byte key to decrypt the entry data, again using the same algorithm
used for the configuration. then comes a 4-byte magic value, which, in all the samples we analyzed,
has to be set to 0x75df9115 for the command to be executed. the entry may also contain the arguments
to pass to the command handler.
finally, sedreco core threads process the inbound file to extract and run the commands. outbound communications
sedreco core threads store the output generated by a command execution in the outbound file,
which is usually named and located in the %temp% directory. similarly to the inbound
file, it consists of a series of variably-sized entries, each entry describing one particular command
execution, as shown in figure 18. plain text data lzw compressed data each entry begins with a 32-byte header, containing in particular a 4-byte magic number (0xb2745daf),
the command return status code, a timestamp of the command execution (in a systemtime
windows structure [19]), and the actual command number. then comes the output data generated
by the command execution, compressed with a custom implementation of the lempel ziv welch
(lzw) algorithm [20]. a source code search engine allowed us to retrieve what we believe
to be the c source code of the lzw algorithm implementation employed
by sedreco [21]. figure 19 shows an extract of the compressed data header
initialization in the source code, with the distinctive lzw! signature.
sedreco network threads regularly usually every 10 minutes fetch the data from the outbound
file and encrypt them with the 3des algorithm and a hardcoded key. the data structure described
in figure 16 is then appended to the encrypted data, thus acting as a footer. in this case, the type
field is set to 1.
finally, the resulting encrypted data are transmitted to the c&c server by sedreco network threads. plugins
an interesting feature of sedreco is its ability to run external plugins. the downloading and execution
of those plugins can be requested by the c&c server with command number 1, while their unloading
can be accomplished with command number 2 (see commands list).
a sedreco plugin comes as a windows dll with two exported functions named init and uninit.
the plugin is loaded in the same address space as sedreco s payload with a call to the windows api
loadlibrarya. the plugin s init export is then called, with the following structure as its argument:
en route with sednit this structure contains some helper functions addresses, plus some data addresses, from sedreco s
payload, that the plugin may need during its execution.
we only found one sedreco plugin during our investigation. once loaded in memory, this plugin
registers a new command, numbered 36, as shown in figure 20. when called by the operators, the newly registered command will open a remote windows
shell over http.
when sedreco exits, the payload unloads all plugins and calls their uninit exports. in the case
of the plugin we retrieved, this export simply unregisters the command it provides, as shown
in figure 21. interestingly, parts of the plugin code are shared with the windows xagent
module named processretranslatormodule (see table 1). in particular,
the function in charge of creating a windows shell process with some com-
munication pipes is exactly the same in both binaries, including some cus-
tom error messages such as #exc_1 cannot create exttoproc pipe!. conclusion and open questions
with its ability to register new commands dynamically, sedreco is a flexible backdoor that has been
used for many years by the sednit group.
an interesting feature of sedreco is the ability to load external plugins. as we only found one plugin,
we hope this report will encourage other researchers to contribute further pieces to the puzzle.
in particular, it would be interesting to search for other code-sharing cases between sedreco plugins
and xagent modules. 75 en route with sednit xtunnel: reaching unreachable machines identikit
xtunnel is a network proxy tool that can relay any kind
of network traffic between a c&c server on the internet
and an endpoint computer inside a local network. alternative names
xaps usage
an xtunnel infected machine serves as a network pivot to contact
machines that are normally unreachable from the internet. known period of activity
may 2013 to august 2016 (the time of writing). probably still in use. known deployment methods
none distinguishing characteristics xtunnel implements a custom network protocol encapsulated in transport layer security (tls) protocol since june 2015, the xtunnel code has been heavily obfuscated, but its strings remain unobfuscated. while written in english,
the strings contain obvious spelling mistakes. en route with sednit timeline
we have analyzed xtunnel samples for three years. the dates posited in the timeline mainly rely
on xtunnel compilation timestamps that we believe have not been tampered with, because
they match up with our telemetry data. the network link between the xtunnel-infected machine and the c&c server is encrypted to complicate
network detection at the external boundary of the network. however, the links with the target
computers remain unencrypted to allow any kind of traffic to be sent to the target. in particular,
it should be emphasized that those target computers are not necessarily under the control
of the sednit group. xtunnel is the developers name for this software. this was determined
by the function export table left unremoved by its authors in several samples.
the developers also forgot to remove program database (pdb) [24] file paths,
from which we can deduce another internal name, xaps . interestingly,
those pdb paths sometimes contain words in russian, such as: en route with sednittarget internal networkinternet traffic proxying
the logic for traffic proxying remained the same in all xtunnel samples that we analyzed, which cover
a period of three years. this core behavior begins with a handshake with the c&c server to establish
an rc4-encrypted link. the c&c server can then order xtunnel to open a tunnel with a designated
machine, so that any data coming from the c&c server will be forwarded to this machine,
and similarly any data coming from the target machine will be forwarded to the c&c server.
this process can be repeated so as to have multiple tunnels opened in parallel, as shown in figure 24
with computers a and b, and as explained in detail in the following section. encryption handshake
xtunnel makes a custom encryption handshake with its c&c server, whose ip address and port
are either given as command line parameters or hardcoded directly in the program. the purpose
of this handshake is to share a cryptographic key for encrypting the link between xtunnel
and the c&c server with the rc4 algorithm. 79 en route with sednit to do so, the xtunnel binary contains a table t composed of 256 rows of 32 bytes each, initially filled
with fixed values in the code, as shown in figure 25. figure 25. extract of t initialization code xtunnel pseudo-randomly chooses one 32-byte row of t as the cryptographic key to share
with the c&c server. the actual handshake then starts by sending the offset o in t of the chosen
row to the c&c server.
this message also includes a proof that the sender really knows t that is, the offset sent is not
just some random 4-byte value. this proof consists of the row located at offset o + 128 (modulo 256)
encrypted with the chosen key. the c&c then checks the proof and, assuming it is correct, answers
ok encrypted with the chosen rc4 key. it should be emphasized that the chosen cryptographic key is never sent over
the network, only its 4-byte offset in t. this prevents traffic decryption
by an eavesdropper not knowing the table and, of course, means
the c&c server also knows t. before going further, the c&c server provides a port number to the infected machine, which
will serve as a fallback in case the connection closes on the currently used port on the c&c server. tunneling
at this point an encrypted link has been established between xtunnel and its c&c server. the c&c server
can then use the xtunnel infected machine as a pivot to contact local computers that are normally
unreachable from the internet. 80 en route with sednit to do so, the c&c server sends messages to xtunnel beginning (once decrypted) with a two-byte
tunnel identifier denoted tunnelid hereafter and followed by data of arbitrary length. when
a particular tunnelid value is sent for the first time, it means the c&c server wants to open a new
tunnel. the information in this first packet contains data about the target machine: either an ip address
or a domain name, plus a port number. two examples of such tunnel-opening messages are given
in figures 26.1 and 26.2. commands 1 and 3 pictured in these messages are the only ones implement-
ed, and xtunnel searches for such a command byte only when it is the first
time it received a particular tunnelid value. xtunnel then makes a tcp connection on the designated target and if successful, the tunnel is considered
fully opened. at this point, each message from the c&c server beginning with the corresponding tunnelid
will be forwarded to the target machine by xtunnel after having removed tunnelid from the message.
in other words, any kind of tcp data can be sent through the tunnel.
on the other side of the tunnel the target machine can also send data, and xtunnel will prefix
it with the associated tunnelid before forwarding it to the c&c server. since in general the size of the data to be transferred is unknown, each
communication between c&c server and xtunnel starts with a 4-byte value
containing the number of bytes to be sent. 81 en route with sednit additionally, the c&c server can send the message is you live? [sic] to check the status
of xtunnel, to which xtunnel answers ok if everything is fine. the quality of xtunnel code is far from being good; here are two examples
of incongruities found in tunneling code: 1. after a tunnel has been opened, xtunnel reports a 6-byte message to the c&c server composed of the ip address and the port of the target
machine. except that the developer forgot to increase the memory pointer
after writing the ip address in memory, and thus the port overwrites the first
two bytes of the ip address. thus, it is likely that the c&c server does
not process this message. 2. the tunnelid sent by the c&c server happens to be also used as the maximum size of data processed from the received packet, for no obvious reason.
consequently, it is impossible, for example, to open a tunnel by ip address
with a tunnelid smaller than 7, because information about the target
computer takes 7 bytes see figure 26.1 , and will therefore be truncated.
we speculate that the c&c server usually chooses large tunnelid values,
explaining why this problem has gone unnoticed by the operators. additional features
eset researchers have retrieved multiple versions of xtunnel, starting in 2013, when it apparently
was first deployed, to mid-2016 for the most recent versions. this allows us to observe over time
the introduction of new features around the core tunneling logic, shedding light on the operator s
objectives and concerns. udp tunneling (august 2013)
xtunnel initially only proxied tcp traffic, but in august 2013 udp traffic tunneling was introduced.
to do so, the c&c server can then ask to open a tunnel over udp rather than tcp.
strangely, the c&c server address used for udp tunneling is hardcoded in the binary ( ),
and any c&c address potentially given as input to xtunnel is ignored even in recent samples.
as this particular c&c server stopped being used mid-2015, we believe udp tunneling was a test
or a feature needed on a particular target, and is not used anymore. in some samples the udp tunneling code contains a few debug messages,
such as: according to those messages, the c&c server is called client udp or tps by the developers, whereas server udp corresponds to the target machine.
the tps acronym remains mysterious to us in this context. 82 en route with sednit tls encryption (april 2014)
a major feature introduced in april 2014 is the encryption of the communications with the c&c server
with the transport layer security (tls) protocol [25]. these new xtunnel binaries are statically linked
with openssl 1.0.1e a version released in february 2013. inside the tls encapsulation, xtunnel
network protocol for tunneling remains the same (including the rc4 encryption). the tls certificate used by the c&c server is not verified by xtunnel,
which means anyone could play the role of xtunnel c&c server. http proxy connection (february 2015)
some organizations force their computers to pass through an http proxy to access the internet.
malware running on such machines therefore cannot contact the c&c server directly, but has to pass
through the proxy. sednit developers took that into account by creating special xtunnel versions
with http proxy awareness.
in these binaries, xtunnel first tries to retrieve the internet explorer proxy configuration by calling
the windows api function winhttpgetieproxyconfigforcurrentuser [26]. in the event that
no information can be retrieved, it uses the hardcoded address :8080, which is the default
address of the squid caching proxy [27]. this intention is clearly stated in the pdb path in one of the
samples: xaps_through_squid_default_proxy.
once a proxy ip address has been chosen, xtunnel uses the http connect method [28] to reach
its c&c server. command line parameter parser (april 2015)
to gain in flexibility and manage novel features, in april 2015 xtunnel developers introduced
a command line parameter parser. this parser accepts the parameters described in table 5.
en route with sednit in most xtunnel samples, the parser actually processes a command line hardcoded in the binary,
without even looking for input parameters. here are some examples of such command lines found
in some samples: the proxy ip addresses shown in these examples do not correspond
to any known default proxy address, indicating that these binaries were likely
compiled for specific targets. http persistent connection (june 2015)
in june 2015, a novel way to connect to the c&c server was introduced: an http persistent
connection [29]. when this feature is enabled, xtunnel exchanges data with its c&c server
over the http protocol (encapsulated in tls protocol), probably as a way to bypass firewalls.
to open such a persistent connection, an http get request is encapsulated in tls protocol and sent
to the c&c server. this request comes with the http header connection: keep-alive to enable
the persistent connection. another http request header hardcoded in xtunnel is accept-language:
ru-ru,ru;q=0.8,en-us;q=0.6,en;q=0.4, which interestingly contains
the language code ru-ru. this header may have been copied from a request
made from a computer whose default language is russian. code obfuscation (july 2015)
in july 2015, xtunnel binaries changed drastically from a syntactic point of view, due to the introduction
of code obfuscation. this obfuscation was applied only to xtunnel-specific code, while statically
linked libraries were left untouched. the method employed is a mix of classic obfuscation techniques,
like insertion of junk code and opaque predicates [30].
consequently, xtunnel binaries are now about 2 mb in size, while the previous non-obfuscated versions
were about 1 mb with most of that being the statically linked openssl library. the obfuscated version
is, of course, much harder to understand and, to illustrate that, the following figures show the control
flow graph (cfg) [31] of a small xtunnel function, before and after obfuscation. figure 27.1 xtunnel cfg before obfuscation 84 en route with sednit figure 27.2 xtunnel cfg after obfuscation while the control flow has been heavily obfuscated, strangely the strings
and data are kept in plain text. we speculate that the developers applied
an (unknown) code obfuscation tool, which was enough to achieve their
goal probably bypassing some security products. conclusion and open questions
we believe xtunnel to be of high importance to the sednit operators, despite the questionable
quality of the code as we discussed in the analysis. in particular, it is the only sednit component
we know with heavy code obfuscation. additionally, the numerous features added over the last
three years indicate an ongoing development effort.
finally, we would like to stress that our analysis is solely based on the capabilities found in the binaries.
in particular, we do not have in-the-wild examples on how xtunnel is deployed, and what kind
of network traffic is usually forwarded. 85 en route with sednit closing remarks
in order to perform its espionage activities, the sednit group mainly relies on two backdoors, xagent
and sedreco, which were intensively developed over the past years. similarly, notable effort has been
invested into xtunnel, in order to pivot in a stealthy way. overall, these three applications should
be a primary focus to anyone wanting to understand and detect the sednit group s activities.
nevertheless, the spying and pivoting capabilities of sednit are not limited to the software
described in this second part of our whitepaper. for example, they regularly deploy the following
on target computers: password retrieval tools for browsers and email clients; some of these tools are custom, while others are publicly available (like the securityxploded tools [32]) windows password retrieval tools, with custom builds of the infamous mimikatz [33] and some custom tools a custom tool to take regular screenshots of the target computer moreover, the sednit group created numerous small executables to perform specific tasks, like
copying or removing files. the developers seem therefore to closely follow the operational needs
of the group, causing us to speculate that they are not outsiders paid for a one-time job,
but fully-fledged members of the group.
