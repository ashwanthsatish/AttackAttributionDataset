operation blockbuster:
destructive malware report 4
1. operation blockbuster
this report details some of the technical fndings of the lazarus group s malware, observed
by novetta during operation blockbuster. we recommend reading the initial report1 prior to
the reverse engineering reports for more details on the operation and the lazarus group.
this reverse engineering report looks at the destructive malware found within the lazarus
group s collection.
one of the more noticeable features of the lazarus group is the use of destructive malware. the lazarus group has two
basic classes of destructive malware. the frst class, colloquially known as wipers, are a class of malware has the primary
intent of destroying data on a victim s machine. a variety of wiper tools have been found within the lazarus group s
collection, each performing its task exceptionally well.
the second class of destructive malware within the lazarus group s collection is distributed denial-of-service malware, or
ddos malware. ddos malware oods a target s network-connected service with an excessive number of request at once
in order to overload the capacity of the server. this overloading results in legitimate trafc being ignored. it is analogous
to have an entire city calling the same it support center at the same time. some people are going to get through while the
majority of people are simply going to get a busy signal as all the available phone lines fll up.
the naming scheme used by novetta for the malware identifed during operation blockbuster consists of at least two
identifers which each identifer coming from the international civil aviation organization (icao) s phonetic alphabet,2
commonly referred to as the nato phonetic alphabet. the frst identifer specifes the general classifcation of the
malware family while the second identifer specifes the specifc family within the larger general classifcation. for
example, deltaalfa specifes a ddos bot family identifed as alfa.http:// civil aviation organization. alphabet radiotelephony . http:// accessed 1 december 2015. 5
first level identifier general classification
delta ddos
hotel http server
india installer
lima loader
kilo keylogger
papa proxy
romeo rat
sierra spreader
tango tool (non-classed)
uniform uninstaller
whiskey destructive malware ( wiper )
table 1 1: first level identifiers for the lazarus group family names and their classification meanings
there is no temporal component to the second level identifers given to malware families. while generally the second
identifers are largely sequential (alfa, bravo, charlie, and so on), the identifer does not indicate that one family came
before another chronologically. instead, the second level identifers were assigned by the order novetta discovered each
particular family.delta
ddos
hotel
http server
india
installer
kilo
keylogger
papa
proxy
romeo
rat
sierra
spreader
tango
tool
(nonclassed)
lima
loader
uniform
uninstaller
whiskey
destructive
malware
( wiper )
indiagolf
indiaalpha
indiabravo
indiacharlie
indiadelta
indiaecho
indiafoxtrot
indiahotel
indiajuliett
indiakilo
indiawhiskey
indiaindia
uniformalfa
kiloalfa
deltaalfa
deltabravo
deltacharlie
hotelalfa
papaalfa
romeoalfa
romeobravo
romeocharlie
romeodelta
romeoecho
romeofoxtrot
romeogolf
romeohotel
romeomike
romeonovember
romeowhiskey
sierraalfa
sierrabravo
sierracharlie
sierrajuliett-mikeone
sierrajuliett-miketwo
limaalfa
limabravo
limacharlie
limadelta
uniformjuliett
tangobravo
tangocharlie
tangodelta
tangoalfa
whiskeyalfa
whiskeybravo
whiskeycharlie
whiskeydelta
the lazarus group 7
2. [wiper] whiskeyalfa
one of the most visible pieces of the sony pictures entertainment (spe) attack, whiskeyalfa is a family of destructive
malware designed to destroy the contents of any hard drives attached to a computer infected with the malware. there are
three known variants of whiskeyalfa: whiskeyalfa-one, whiskeyalfa-two, and whiskeyalfa-three. whiskeyalfa-one is a
simplifed variant that focuses purely on the destruction of a victim s data. whiskeyalfa-two, the variant associated with the
spe attack, performs this same destruction but also drops an additional malware family, hotelalfa.3 whiskeyalfa-three is a
modifed version of whiskeyalfa-two that also includes a spreading mechanism specifc to the spe infrastructure.
the whiskeyalfa malware variants contain two primary attacks for destroying a victim s data: attack type 1, a.k.a. fileoverwrite, overwrites all fles with random data from the heap (up to 4,194,304 bytes) attack type 2, a.k.a. sectoroverwrite, uses a raw disk access driver to overwrite sectors of the victim s hard drives with
random data
the fileoverwrite attack begins by recursively identifying all fles on the victim s machines for each drive assigned a letter (e.g.
c:, d:, and so on). due to the fact that identifying each fle on a set of drives can be a time consuming process, the
fileoverwrite attack is performed within its own thread making it asynchronous to any other attack types that may also be in
play on a victim s machine infected with whiskeyalfa. for each fle that matches a variant-specifc condition or set of conditions, which will be explained in the variants subsections that follow, whiskeyalfa will apply a quasi-secure deletion function.
the whiskeyalfa deletion technique for fles is not the same used in other lazarus group variants but rather a crude
overwrite technique. the quasi-secure deletion function will overwrite a specifed fle by allocating a bu er from heap
memory equal to the size of the fle up to a maximum of 4,194,304 bytes, followed by writing the contents of the bu er to
the fle using writefile. the end result of this type of overwrite is the simple replacement of data for a given flename
using artifacts from memory.
the sectoroverwrite attack relies on the eldos rawdisk4 driver in order to access the hard drive directly (thus largely
skipping the windows hardware abstraction layer and avoiding operating system safeguards). in order to activate the
eldos rawdisk driver, whiskeyalfa must frst drop the driver to the victim s hard drive and then activate the driver by
installing it as a service that whiskeyalfa must start. since the rawdisk driver is architecture-specifc, whiskeyalfa
contains both a 32-bit and 64-bit version of the binary within its resource section under icon_packages\129 (32-bit)
and icon_packages\131 (64-bit). the rawdisk driver is encrypted using an encryption scheme novetta was unable to
identify. whiskeyalfa will drop the appropriate rawdisk driver to %temp% after decrypting the driver.
in order to activate the driver, whiskeyalfa must frst install the driver as a service. whiskeyalfa uses the windows services
api function createservice to add a new service named usbdrv3 to the windows services database. the new service is
given the display name of usb 3.0 host controller and the %temp% fle is specifed as the service executable. if a service with the name usbdrv3 already exists on the victim s machine, it is stopped prior to the installation of
whiskeyalfa s usbdrv3 in order to prevent the rawdisk driver from improperly activating due to a service name collision.
eldos s rawdisk driver has been used by other destructive malware families, most notably shamoon in mid-2012,5 priorhttp:// . direct access to disks and protected files from user-mode applications in windows - rawdisk . accessed 25 november 2015.dmitry tarakanov. securelist. shamoon the wiper: further details (part ii) / 11 september 2012. 8
to its inclusion in samples of whiskeyalfa, a malware family with a short known life span that includes only the month of
november 2014. unlike shamoon, which used the rawdisk library for accessing the drive, whiskeyalfa directly interfaces
with the driver and thus cuts out the use of the rawdisk library. while this is a seemingly minor optimization, it points to
a level of familiarity with the rawdisk system that clearly the author(s) of shamoon did not have or choose to use.
whenever a program needs to access the rawdisk driver, the program must open a fle handle through a specifcally
formatted filename. depending on if the program needs to access the rawdisk driver for the physical drive
(e.g. \\.\physicaldrive0) or for the logical drive (e.g. c:\), the flename that the program requests through createfile
must contain a hash character (#) followed by the license key issued to the developer by eldos. for example, when whiskeyalfa opens an interface to the rawdisk driver for the physical drive on a victim s computer, the malware will open the
in either mode, the important component is the license key, as rawdisk will fail to open an interface to itself if the license
key is invalid. the developer(s) of shamoon used an easily obtainable temporary license key that has a built in expiration date and is registered to binnatova@ . this is the reason that shamoon required the
current time of the victim s system to exist within a very specifc window. whiskeyalfa, however, got around the expiration date issue by using a legitimate license key from another product: the fle utilities from briggs softworks.6 the
license key found in whiskeyalfa has an expiration date of 22 september 3378 16:43:04 and the license name of briggs
softworks (single-dev vendor). the fact that the developer(s) of whiskeyalfa used a stolen license key parallels
the lazarus group s use of compromised infrastructure, as it provides a necessary resource to the group without directly
relatable evidence pointing back to the parties involved.
with the rawdisk driver installed, the sectoroverwrite attack begins by generating three bu ers: a bu er consisting of
65,536 0xaa bytes, a bu er of 65536 0x55 bytes, and a bu er of 65,536 random bytes. these bu ers become the basis for
the data written to sectors on a victim s hard drives. the frst phase of the sectoroverwrite attack consists of using the
rawdisk driver to access the physical disks 0 through 29 and overwriting the frst 64 mb of the drives with the contents
of the three bu ers (in order of 0xaa, 0x55, and random). the next phase of the attack uses the rawdisk driver to access
the logical drives starting at drive z: and working backwards through to drive c:, with each drive having specifc areas
overwritten using the three bu ers. the next phase of the sectoroverwite attack is particularly aggressive as 300 threads
are generated for the potential of physical drives 0 through 299 being attacked by having every byte of every sector of the
drives replaced with random data. the last phase of the sectoroverwrite attack consists of attempting to call
getdiskfreespaceex against each of the possible lettered drives z: through c:. for any drive that returns a
successful result, the sectoroverwrite attack assumes the drive was not successfully damaged and will attempt to overwrite
a signifcant number of sectors with data from the random bu er generated at the beginning of the attack. the attack
concludes with a call to sleep with the value set to infinite. if sleep does return eventually, then the usbdrv3 service
by far the most simplifed version of whiskeyalfa, whiskeyalfa-one has a singular focus: destruction of data. wrapped
in a simple windows gui framework, whiskeyalfa-one begins by deleting the windows event logs system, security,
application, and setup by either calling the api function evtclearlog from or by issuing the
command cl via a createprocess call.
whiskeyalfa-one proceeds to use the fileoverwrite attack followed immediately by the sectoroverwrite attack. once the
attacks complete, assuming that the sleep function ultimately returns and the driver is removed, a suicide script is then
generated and executed. the suicide script generation function uses string concatenation functions and shellexecute
to execute the script, as seen in the code in figure 2-1:
figure 2 1: code snippet of whiskeyalfa one's suicide ssript generation function
the suicide script s generation and format is nearly identical to that of indiaalfa-one, with the exception that the frst
del command is missing the /a h parameter. it is worth noting that whiskeyalfa-one has the same super uous
strcpy(buffer, "@echo off\r\n") instruction found in indiaalfa-one. a race condition begins once the suicide
script executes, as the very next function that whiskeyalfa-one calls shuts down the windows operating system by
calling the exitwindowsex function. depending on how quickly the operating system shuts down, it is possible that the
suicide script will not have a chance to complete its task; however, the devastation that whiskeyalfa-one has in icted on
the victim s hard drives makes the need for a suicide script somewhat unnecessary. 10
2.2 whiskeyalfa two
whiskeyalfa-two is more feature rich than its sibling, whiskeyalfa-one, but ultimately it serves the same purpose:
the wholesale destruction of data. whiskeyalfa-two takes a set of optional ags to determine its particular mode of
operation. table 2-1 below identifes the various ags that whiskeyalfa supports. if the malware is executed without any ags, whiskeyalfa-two will merely execute itself again with the i ag as its argument, causing the malware to install
itself as a service on the victim s computer. e ectively, whiskeyalfa-two has the capability to self-install.
flag operating mode meaning
-d service perform the fileoverwrite attack on non-executable (.exe and .dll) files
-i stand-alone install whiskeyalfa on the victim s machine as a service
-k service or stand-alone perform fileoverwrite and sectoroverwrite attacks, install hotelalfa, report status
to c2 server and shutdown the microsoft exchange information store service
(msexchangeis) before shutting down the victim s machine after two hours.
-m service perform the sectoroverwrite attack
-w service install and activate hotelalfa
table 2 1: whiskeyalfa two s supported command line flags
the installation process is straightforward:
1. call createservice to create a new windows service named brmgmtsvc with the display name of backup
and restore management service 2. set the description of the service to backup and restore management service and establish the error
recovery conditions by calling changeserviceconfg2
3. activate the service by calling startservice
when running as a service, whiskeyalfa-two can perform a variety of attacks. the fileoverwrite attack (argument d)
will attack all non-executable fles (fles that do not have an .exe or .dll extension) on a victim s letter-assigned drives.
some variants of whiskeyalfa-two will avoid removing fles from the %programfiles% directory as well as %windir%.
whiskeyalfa-two can also drop hotelalfa when executed with the w argument. the process of installing hotelalfa
begins by whiskeyalfa-two stopping the windows terminal services service (termservice). the hotelalfa binary
is then decrypted and extracted from the whiskeyalfa-two resource icon_packages\133 and saved on the victim s
machine as %windir% . hotelalfa is activated by calling createprocess with the flename and path of
the binary.
activating the various attack types and install the hotelalfa malware as individual steps can be cumbersome and this
could be the reason that the developer(s) of whiskeyalfa-two supplied the k command. when called with the k
argument, whiskeyalfa-two will delay 10 minutes after being activated before executing itself with the w argument
supplied to start the installation of hotelalfa. after 3 seconds, whiskeyalfa-two spawns a new instance of itself with
the m argument supplied to induce the sectoroverwrite mode. an additional 3 seconds later, whiskeyalfa-two generates
another copy of itself with the d argument supplied to start the fileoverwrite attack. whiskeyalfa-two will report victim
information back to one of three hardcoded c2 server. the data that whiskeyalfa-two sends to the c2 server consist of a
40-byte data structure defned in table 2-2. 11
[dword]: local ip address of victim
[32 bytes]: computer name
[dword]: flag (set to 4)
table 2 2: whiskeyalfa two s status structure
the data to the c2 server is sent without encryption, and the c2 server does not respond with any additional packets.
this would indicate that the data burst to the c2 is merely a status update transmission that allows the lazarus group to
determine which machines have su ered from a whiskeyalfa-two attack.
once the status report has been transmitted to a c2 server, whiskeyalfa-two stops the msexchangeis service. the
msexchangeis service is the microsoft exchange information store service that is responsible for housing the contents
of an exchange email server (i.e. emails, contacts, etc). two hours after stopping the exchange server, whiskeyalfa-two
will shut down the victim s machine by calling the exitwindowsex function. 12
2.3 whiskeyalfa three
whiskeyalfa-three is an enhanced version of whiskeyalfa-two. the primary di erences between whiskeyalfa-three
and whiskeyalfa-two is the inclusion of a windows share fle deletion option, an option to drop and run tangodelta, as
well as the expansion of which fles the fileoverwrite attack will target. whiskeyalfa-three also adds three new command
line arguments, as seen in table 2-3, while removing the w argument.
flag operating mode meaning
-a service disable avs using tangodelta.
-n service fileoverwrite attack against any file so long as the drive is drive_fixed,
drive_removable, drive_ramdisk, or drive_remote
(this is an expansion of targets from the -d command that only allows for
drive_fixed and drive_removable.)
-s service attempt to login to predefined spe servers and delete all files on all shares.
table 2 3: whiskeyalfa three s additional supported command line flags
when the a argument is supplied to whiskeyalfa-three, it begins the process of extracting and decoding two fles from
its resource section but only if the host operating system is 64-bit. resource icon_packages\137 contains the process
hacker driver, which whiskeyalfa-three will save as %temp% , and resource icon_packages\136 contains
the tangodelta binary that ultimately gets saved to %temp% . with the tangodelta components dropped to the
victim s hard drive, whiskeyalfa-three uses createprocess to activate the tangodelta malware.
while whiskeyalfa-three contains the same fileoverwrite attack found within whiskeyalfa-two variants,
whiskeyalfa-three contains an additional mode (argument n) that will expand the allowable targets from only fxed
(hard drives) and removable (such as usb drives and oppy disks) drives to include ram disk and remote drives.
whiskeyalfa-three enforces the condition that it will avoid removing fles from the %programfiles% and %windir%
directories. additionally, the n argument will change the wallpaper of the user account under which whiskeyalfa-three
is executing to the image seen in figure 2-1. as will be discussed later, whiskeyalfa-three uses the n argument mode
when attacking user accounts logged onto a whiskeyalfa-three infected machine, which makes the inclusion of the
wallpaper replacement somewhat less bafing. 13
figure 2 1: wallpaper of users infected with whiskeyalfa three
the sectoroverwrite attack within whiskeyalfa-three operates in roughly the same manner as the other whiskeyalfa
variants with the exception of a very specifc modifcation made to the master boot record (mbr) of targeted drives.
whiskeyalfa-three replaces the mbr (sector 0) of each physical drive with the code fragment shown in figure 2-2. 14
figure 2 2: whiskeyalfa three s mbr trojan code 15
the whiskeyalfa-three mbr trojan performs the following tasks:
1. overwrite 64 sectors starting at sector 1024 with random data 256 times (the random data to use is located at
0000:0000 through 0000:7fff in 16-bit mode)
2. copy the current mbr to each attached physical drive.
it would appear that the mbr modifcation of whiskeyalfa-three acts as a form of failsafe in the event that a drive s
destruction was not completed by the time the victim s computer shut down. the use of the mbr to further the destruction of a victim s hard drive data is a testament to the motivation of the whiskeyalfa developer(s) to ensure complete
devastation of the victim s data.
whiskeyalfa-three is most defnitely a targeted piece of malware, as it includes a mode (via the s argument) that will
attempt to connect to a series of servers that most likely belonged to spe infrastructure and delete all of the fles available
via shares on the servers. the attack, shareshredder, begins by attempting to connect to each of the hardcoded servers by
name, as identifed in figure 2-3.
figure 2 3: targeted infrastructure found within whiskeyalfa three
to connect to the servers, whiskeyalfa-three issues the following command via createprocess: /c net use servername p@ssw0rd123 /u: spe\adutta2-1 > random_pid
the servername value is the name of the server to which a connection is being requested, random is the current
value from gettickcount, and pid is the current pid of the whiskeyalfa-three process. the log fle that the command
produces (the random_pid fle) is scanned to determine if successfully is present, indicating that the connection
to the server was successful using the supplied credentials; the fle is then deleted. 16
if a connection to the targeted server was successful, a call to netshareenum is made to determine the available shares
on the server. from the list of shares available, whiskeyalfa-three will randomly select one share as its target for data
destruction. it is interesting that the developer(s) chose to limit the destruction of data to a single share per host infected
by whiskeyalfa-three. the data destruction process consists of recursively identifying each fle and directory within a
share for the windows api function deletefile to remove the fle.
whiskeyalfa-three modifes the behavior of the k mode slightly from that seen in whiskeyalfa-two. upon activation,
whiskeyalfa-three will call sleep for a suspension of 2 hours before issuing the various other modes. after the sleep
delay, whiskeyalfa-three will execute itself with a to drop tangodelta. a fve second delay later, whiskeyalfa-three will
spawn new instances of itself with the m argument, then the d argument, and fnally the s argument. after issuing
the various attack modes, whiskeyalfa-three will enumerate all logged-on users and attempt to run itself with the n
argument as each logged-on user. whiskeyalfa-three then reports victim information back to one of three hardcoded
c2 server using the same method as whiskeyalfa-two. but unlike whiskeyalfa-two, after the data burst to the c2 server,
whiskeyalfa-three does not shut down any additional services or the victim s system. the fact that whiskeyalfa-three
attempts to run itself as loggedon users and does not shut down the victim s computer may indicate that the malware was
designed to target a terminal services-enabled server that would be immediately noticeable if rendered inoperative, but at
the same time the malware announces itself by replacing infected users desktop wallpaper. 17
3. [wiper] whiskeybravo
destructive malware doesn t need to be overly complicated, as whiskeybravo proves. observed being installed as a service
by indiagolf, notably during the ten days of rain incident as reported by mcafee,7 whiskeybravo has only two tasks:
destroy then delete all fles on the victim s machine and overwrite all sectors on the victim s hard drive (or only the mbr if
the victim is using the windows vista or newer operating system).
there are two observed variants of whiskeybravo: whiskeybravo-one and whiskeybravo-two. from a code perspective,
whiskeybravo-one and whiskeybravo-two are extremely similar, with the latter being simpler despite being chronologically newer. the primary di erence between the two is that whiskeybravo-two simplifes the fle overwrite and deletion
task somewhat. given their high similarity, it is easiest to look at the generic functionality before delving into the subtle
di erences of the variants.
before whiskeybravo can begin its destructive tasks, it must frst determine if the victim s machine is within a target
time range. dropped as part of the installation process by indiagolf, the fle %sysdir% contains a 12-byte
data structure the defnes the operating period for whiskeybravo and will be referred to in this section as the operation
confguration fle. the format for the fle is as follows:
offset size default value (as set by indiagolf) description8-bytes (double) current system time at time of whiskeybravo
installation in varianttime format. whiskeybravo s installation time.4 7 activation delay (in days)
table 3 1: whiskeybravo s configuration file format
whiskeybravo will remain in a perpetual state of waiting to activate until one of three conditions occurs:
1. the victim s system time is set to a time prior to the installation time (o set 0).
2. the victim s system time is later than the sum of the installation time (o set 0) and the activation delay (o set 8).
3. [whiskeybravo-one] the fle %sysdir% exists and contains a 32-bit value of 0.
once the activation window has occurred on the victim s computer, whiskeybravo will spawn two threads: a thread for
destroying select fles on the victim s hard drives and a thread for overwriting sectors on the victim s attached physical
drives. despite using two threads, one per task, the operations are performed sequentially, not in an asynchronous
manner as the use of multiple threads would suggest. after a new thread is generated for an operation, a call is made to
waitforsingleobject to wait for the thread to return with the timeout set to infinite. it is therefore unnecessary
for the developer(s) of whiskeybravo to use two threads in the frst place.
the task of destroying select fles from the victim s machine occurs on all lettered drives on the victim s machine, starting
at z: and going through a:. for each lettered drive, whiskeybravo uses the findfirstfilew/findnextfilew api
functions to enumerate each directory and fle on the drive with the exception of %windir% and %programfiles%,ten days of rain: expert analysis of distributed denial-of-service attacks targeting south korea. mcafee. 2011. http:// 18
which are explicitly ignored; this behavior is also observed in whiskeyalfa (see section 2) and whiskeydelta (see section
5). the selection criteria for a fle to be overwritten and deleted is based solely on its extension using the target fle identifcation function detailed in section 4.3.6 of the operation blockbuster report.8 the method for destroying selected fles
di ers by variant.
after completing the fle destruction task, whiskeybravo begins overwriting potentially large portions of each physical
drive attached to the victim s computer. interestingly, the developer(s) of whiskeybravo attempt to access
\\.\physicaldrive0 through \\.\physicaldrive24; however, windows has an upper limit of
\\.\physicaldrive15, indicating that the developer(s) were either being sloppy in their coding or were potentially
mistaking a logical drive (a lettered drive) for a physical drive.
for each physical drive that whiskeybravo is able to access, a call is made to getversionex to determine the type of
operating system the victim is using. for victims running windows vista or newer, whiskeybravo attempts to overwrite
with null bytes the frst 4.9 mb of the victim s physical drives. if whiskeybravo is running on a machine with windows
xp or older versions of windows that have less restrictive access to the physical drives through the
\\.\physicaldrivex interface then the overwriting of data with null bytes starting at sector 0 extends upwards
of 39.1 gb. the code for the sector overwrite function in figure 3-1 reveals the developer(s) of whiskeybravo s rudimentary understanding of how the \\.\physicaldrivex interface works or at the very least a sloppy implementation of a
multiple pass overwrite operation.
figure 3 1: whiskeybravo s physical drive overwrite function (snippet)
if the intent was to render the frst sector (512 bytes) or frst 4 mb of a hard drive unusable depending on the victim s
operating system and thereby destroy the mbr and upwards of 4 mb worth of data that follow the mbr, then the developer(s) forgot to reset the fle pointer back to the beginning of the do-while loop; as the code is implemented, each additional call to writefile will increment the location of the write by 512 bytes or 4 mb. if, however, the intent was to
overwrite a signifcant chunk of the victim s hard drive, the operation will fail on versions of windows that are vista or
newer due to the restrictions these operating systems have on using \\.\physicaldrivex for direct disk access. this
suggests a certain level of developmental carelessness assuming that the intended targets had vista or newer installed,
even basic testing should have discovered this failing.http:// 19
3.1 whiskeybravo one
the %sysdir% fle is not a by-product of indiagolf. it appears that the fle, if introduced by an external
application, can override the activation delay by containing the value of 0 or extend the activation delay up to 10 days by
having a positive value. whiskeybravo limits the activation delay to 10 days. any modifcation to the activation delay by
the introduction of the %sysdir% fle will force whiskeybravo to save a new copy of the %sysdir% fle to disk. however, once whiskeybravo is in attack mode and no longer in wait mode, the %sysdir% fle
will have no impact on whiskeybravo s operation. in other words, once the operation begins it cannot be stopped short of
terminating the whiskeybravo process.
whiskeybravo-one both overwrites and deletes any fle selected for destruction. for any fle that whiskeybravo-one
selects for destruction, the fle endures the following sequence of events:
1. the fle s attributes are changed to file_attribute_normal to remove a possible read-only ag
2. the size of the fle is used to generate a heap memory bu er that matches the same size of the fle with an upper limitmb
3. the heap memory bu er is zeroed out and written over the entirety of the selected fle starting at byte 0
4. if the selected fle is less than 10 mb, a zip fle is generated having the same flename as the selected fle with a .cab
extension added. the selected fle is stored, not compressed, within the new zip archive and secured with a randomly
generated 8-character password.
5. if the .cab fle is generated and has a size smaller than the original selected fle, up to 4 mb of null bytes are
appended to the end of the .cab fle until it reaches a size equal to that of the original selected fle.
6. the selected fle is deleted using deletefilew.
several items are noteworthy regarding the method that whiskeybravo-one uses to destroy a fle. first, the code that
generates the .cab fle can be found in other lazarus group malware families and constitutes nearly 77% of the non-c
runtime (crt) library functions within the whiskeybravo-one executable. secondly, the end result is that the destruction operation can give the impression that the original selected fle is recoverable if the user is able to crack the archive s
password. this is a bit of a cruel joke to play on the victim by giving them a glimmer of hope when, in actuality, the fle is
most defnitely destroyed and attempting to recover the fle via the archive would be fruitless and a waste of resources. 20
3.2 whiskeybravo two
whiskeybravo-two is a simplifed variant of whiskeybravo-one that removes the functionality from the
activation window determination code as well as the archive functionality from the fle destruction code. whiskeybravo-two
expects the operation confguration fle to be located at %sysdir%\tyei08.dep instead of %sysdir% .
the fle destruction process within whiskeybravo-two focuses solely on overwriting the contents of a fle and ignores the
task of deleting the fle. this results in any fle marked for destruction remaining on the victim s fle system, with the same
fle size, but with completely useless content. furthermore, whiskeybravo-two removes the .cab generation entirely. the
removal of the .cab generation, and the functions necessary for that operation, results in a signifcantly smaller binary
footprint that consists of a total of 21 functions, 8 of which are made of the crt library and 3 are administrative overhead
(service related), leaving 10 functions responsible for the destructive functionality of the malware. 21
4. [wiper] whiskeycharlie
the malicious malware identifed by novetta as whiskeycharlie is a confgurable hard drive contention destroyer.
observed as one of the payloads of indiadelta and loaded into memory and activated by limaalfa, whiskeycharlie is a
dll-based wiper that goes to great lengths to ensure the complete destruction of data on a victim s hard drives.
whiskeycharlie contains only one exported function, the function named register. this function requires three
arguments, all null-terminated strings: a string defning the location of a command fle, a string defning the
decryption string for the command fle, and a string specifying the number of seconds to delay before whiskeycharlie
begins processing the command fle instructions. the core of whiskeycharlie is incredibly simple:
1. verify that the delay string is a real number (consists of characters between 0 and 9)
2. load the command fle into memory
3. delete the command fle from disk
4. delay the number of seconds specifed before processing the command fle instructions
5. process the command fle instructions
6. terminate
the command fle consists of a sequence of command instructions each made up of a minimum of 8 bytes. table 4-1
identifes the format for whiskeycharlie insutrctions within the command fle.
offset size field id description4 bytes type instruction type4 bytes size size of the entire instruction (minimum value is 8, maximum
value is 4095)variable (0 or more bytes) args instruction s arguments
table 4 1: whiskeycharlie's command file instruction format
the developer(s) of whiskeycharlie encrypt the contents of the command fle by using a variable length xor string.
since xor decryption is somewhat trivial on fles that contain a signifcant number of null (0) values in the original
decrypted data, the developer(s) use junk bits within the type and size felds and merely bitwise-and o the unnecessary bits after decryption. for example, the type feld consists of 4 bytes on disk, but from the perspective of the command
processor only the least signifcant byte is important. therefore, the value 01 03 46 08 after decryption for the type
feld is reduced to just 01. similarly, the size feld is masked with 0xfff meaning that more than half of its bits on disk
are junk bits.
the decryption string is supplied by the user of whiskeycharlie, making decryption of the command fle difcult (but
not impossible) without frsthand knowledge of the correct decryption key. interestingly, there is no code that attempts to
verify the correct decryption of the command fle. the command fle will be decrypted using whatever string was supplied
by the user and then processed regardless of its validity. 22
whiskeycharlie contains 22 di erent supported commands, seen in table 4-2 below. while currently only one sample of
whiskeycharlie has been found in the wild (which is not surprising given its ability to completely destroy a victim s hard
drive), evidence suggests that there are other whiskeycharlie samples that have been developed. this theory is supported
by the fact that there are 3 missing commands within the command processor of the analyzed whiskeycharlie sample.
instruction
type
internal
name description[mode]
sets the number of overwrite iterations the various delete commands will perform.
takes a single ascii decimal number as the argument for the command. valid
values are: 0, 1, 3, and 5. 0 will disable the overwrite functionality, and values
outside of 1, 3, and 5 will default to 7 overwrite iterations.[file]
securely deletes a file by overwriting the file with random data (the number of overwrites is determined by the value set by command 1). the file s name is replaced
with a randomly generated string consisting of only upper-case letters. the
command takes a single argument which is the target file to delete.[dirr]
performs a secure delete (see command 2) for all files within a specific directory
that match a given file mask. the command takes two arguments separated by a |
(pipe) character. the structure of the arguments is <target directory>|<file mask
string>. files that do not match the file mask (e.g. *.exe) are not deleted.[dira] same as command 3 but will recursively delete all files in child directories of the
target directory.[ntfs]
produces 10000 files in a target directory (or %temp% if no directory is specified)
with the name pattern of ~wd{8 digit random number}.log, writes its own filename
within the file, renames the file to ~wd{another 8 digit random number}.tmp, and
then deletes the file. e ectively, this is wiping artifacts that may exist in the ntfs s
directory tree by producing a significant number of files (and thus filenames) which
it then frees. the command takes a single, optional argument of the target directory
to produce the files within.[wow64]
changes the state of the wow64 file redirection (e.g. accessing system32 in either
32-bit or 64-bit mode changes based on process type). takes a single argument of
either on or off.[regk]
deletes a registry key. takes a single argument which specifies the full path of the
registry key. the registry key must include the hive name in the form of
hkey_local_machine, hklm, hkey_current_user, hkcu,
hkey_classes_root, or hkey_users.[regv]
deletes a registry key and its values as well as any subkeys and values. takes
a single argument which specifies the full path of the registry key. the registry
key must include the hive name in the form of key_local_machine, hklm,
hkey_current_user, hkcu, hkey_classes_root, or hkey_users.[regt]
modifies the last write timestamp of a specified registry key to a random date
between jan 1, 2007 and dec 28, 2013 (where months will never exceed 28 days).
takes a single argument which specifies the full path of the registry key. the
registry key must include the hive name in the form of hkey_local_machine,
hklm, hkey_current_user, hkcu, hkey_classes_root, or
hkey_users.[svc] terminates and deletes the specified service. the command takes a single
argument which specifies the name of the service to remove.[pf]
deletes the prefetch files from %windir%\prefetch directory using the
same secure delete method as the [fle] command. the optional argument to
the command specifies a specific prefetch (.pf) file to delete or a file mask that
specifies the prefetch files to delete. if the optional argument is missing, then all
.pf files are deleted.[run] executes the specified program in a hidden window. the command requires two
arguments (separated by |): <cmd line to execute>|<working directory> 23
instruction
type
internal
name description[runw] same as the [run] command but waits for the program to terminate before
continuing to the next command.[kill] terminates a running process by name. takes a single argument which specifies the
name of the program to determine.[hc] nop[evc]
destroys one or all events logs by (for windows xp and older) calling
cleareventlog to purge the log and then using the [fle] command to delete
the backup .evt file or (for windows vista and newer) calls evtclearlog (from ) or uses cl <event log> /bu:<backup file
name> then uses the [fle] command to delete the backup file. the command
takes a single argument that specifies the event log to delete or * if all event logs
are to be deleted.[evr] nop[evs] nop[mu]
removes one or all applications from the most recently used (mru) programs
list within windows. the command takes a single argument that specifies the
name of the program to remove from the mru list or * if all programs are to be
removed. the command purges values that match the specified program (or all
programs if * is given) under the following registry keys: hkcu\software\
deletes ie cache files. the command requires two arguments separated by | with
the first argument being the file mask to specify which cache files for the command
to target and the second argument specifying the user profile to target.[iei]
deletes cookies, browsing history and download history files from
%csidl_history%, %csidl_cookies%, %csidl_internet_cache%,
%csidle_cookies%\iedownloadhistory directories. the command takes
an optional single argument that specifies the user profile to target.[swap]
purges the page file by enabling the clearing of the page file at shutdown (by setting
hklm\system\currentcontrolset\control\session manager\
memory management\clearpagefileatshutdown to 1) and then generating an excessively large amount of memory to fill up the swap space (page file).
[hard]
systematically destroys the contents of a victim s hard drives by performing the
following tasks:
a random string of uppercase letters after overwriting their contents and then
deletes them.
the command takes only one optional argument that specifies if the victim s files
are deleted or not (when * is given).[self] generates and executes a suicide script.[sleep] sleep delay. takes a single argument that specifies the sleep time in seconds in
ascii decimal form.
table 4 2: instructions of whiskeycharlie 24
one of the most destructive features of whiskeycharlie is its secure delete function. this variant of secure delete consists
of performing the following operations on a target fle:
1. if the fle is read-only, make it writable
2. based on the value set by the [mode] command, determine the number of overwrite iterations to perform on the fle.
the default value is 7, but it is possible to specify 1, 3, or 5 iterations. the overwrite functionality can be disabled by
supplying the [mode] command the value of 0
3. perform an overwrite operation on the specifed fle, repeat until all requested iterations have been completed
4. rename the target fle s flename by replacing each character with a randomly selected uppercase character
5. delete the fle by calling the api function deletefilea
the overwrite operation that whiskeycharlie uses during secure delete operations begins by generating a 64kb bu er
of random values (as supplied by 64k calls to rand), the target fle is opened and one byte is appended to the end of the
fle, then each byte of the target fle is overwritten with a value from the random value bu er, the writes are then ushed
to disk. on the last iteration of the overwrite operation, the fle size is set to 0 by calling the setendoffile function
and then the changes to the fle are ushed to disk by calling flushfilebuffers. this means that not only is the data
within the fle completely destroyed by one or more iterations of random data being written over the original data, but the
fle s size is also corrupted, making it difcult to determine how big the fle was originally.
while the command fle is encrypted, as mentioned previously, it was possible to recover the decryption key string
of m140chi1a0shi! and decrypt the contents of a known command fle dropped by indiadelta (sample sha-256:
shows a real world example of how the attackers use whiskeycharlie to attack a victim s computer. the command fle
consists of a signifcant number of service deletions and fle deletions prior to performing a full hard drive destruction
task. it is clear from the nature of whiskeycharlie s instruction set and the recovered command fle that the use of
whiskeycharlie on a victim s machine is the fnal stage of an attack, as there will be no usable data left on the victim s
hard drive once the malware has completed its task.
command arguments description of action
table 4 3: contents of a whiskeycharlie command file found in the wild 26
5. [wiper] whiskeydelta
whiskeydelta is a family of destructive malware that destroys all the data on a victim s hard drive on the fle system and
sector level. there are two known versions of whiskeydelta, whiskeydelta-one and whiskeydelta-two. whiskeydelta-one
represents a baseline for the feature set within the whiskeydelta family, while whiskeydelta-two adds c2 communication,
wraps the core whiskeydelta code within a service executable, and renames the administrator account.
the core whiskeydelta functionality consists of the following tasks:
1. decrypt the name of two services (alerter and sens) as well as the data blob that whiskeydelta uses to replace
the mbr of attached hard drives
2. stop the alerter and sens services on the victim s computer
3. get partition information for all physical drives
4. replace the mbr for each physical drive attached to the victim s computer with a trojanized mbr and corrupt the
partition table
5. enumerate all fles on all lettered drives (c:, d:, etc.) and delete the fles that meet a specifc criteria (which is variant-specifc)
6. overwrite the frst 132 mb (whiskeydelta-one) or 1.5 mb (whiskeydelta-two) of each partition of each physical
drive with random data from heap memory
7. [windows xp or older] overwrite each sector of each partition of each physical drive with random data from heap
memory or [windows vista or newer] overwrite 0x7c00 bytes starting at sector 1 with random data from heap memory
whiskeydelta uses a decryption scheme that di ers from the majority of the lazarus group s families. seen in figure
5-1, the scheme consists of multiple xors to mutate an array and then apply an xor to each byte of the encrypted data.
whiskeydelta uses the encryption scheme to decrypt the names of the two services to stop (task 2) as well as the data
blob containing the mbr trojan (task 4). whiskeydelta-one requires that the key to decrypt the data be present on the
command line while whiskeydelta-two supplies the key. fortunately for analysts, the key appears to be the same across
both variants: uancspwjk9dbyduoaxbcq0dzzf3jzkdi. 27
figure 5 1: whiskeydelta s decryption function
task 4, the mbr replacement (seen in figure 5-2), has remarkable structural and functional similarities to the mbr trojan
used by whiskeyalfa-three (see section 2.3) in the spe attack. the mbr trojan begins by reading a copy of the frst drive s
(drive 0x80) mbr into memory at 0000:7000 (using the real mode memory model). the mbr trojan enters an endless
loop where the following events occur:
1. random data from memory at 0000:0000 through 0000:ffff is written to each physical drive starting at sector 0
and incrementing by 192 sectors for 256 writes per drive.
2. the original mbr is copied to the sector 0 of the frst physical drive (drive 0x80)
3. the loop repeats indefnitely.
the disk access packet (dap) specifes that the disk write operation will overwrite 128 sectors with random data from
memory at 0000:0000 through 0000:ffff, but after each write the pointer to the next sector is incremented by 192
sectors, meaning that 64 sectors are left untouched for each write. it is unclear why the start of the next write operation is
incremented by 192 when the memory write is 128 sectors. the 128 sector limitation, in this case, is most likely due to the
64kb boundary issue that occurs in 16-bit mode. in any case, assuming an ideal situation, the mbr trojan will destroy the
data on the attached hard drives. 28
figure 5 2: whiskeydelta s mbr trojan code 29
prior to writing the mbr trojan to the physical disks, the partition information is destroyed by replacing the starting
sector lba value, the partition type value, and the starting sector chs address values with random data. this renders
the partition type information inaccessible by means of parsing the mbr going forward, but it would still be possible to
look at the size of the partition by the partition size feld and the partition s end sector lba value to calculate the original
starting sector lba.
after replacing the mbr with the trojanized mbr, whiskeydelta begins the process of destroying fles from the victim s
computer by enumerating all the fles on all of the lettered drives. starting at drive a: and progressing through drive
z:, whiskeydelta recursively scans through each directory and their subdirectories looking for fles that meet a specifc
criteria, typically a specifc fle extension as explained in following sections on the whiskeydelta variants. whiskeydelta
does not enumerate any fles within the %windir% and %programfiles% directories. for each fle found that meets the
criteria for destruction, whiskeydelta overwrites the fle with random data. the specifcs of the overwrite are variant-dependent. after overwriting a fle s contents, the fle is deleted.
whiskeydelta performs two di erent sector overwrite attacks. using the partition information obtained during task 3,
whiskeydelta overwrites either 132 mb (whiskeydelta-one) or 1.5 mb (whiskeydelta-two) starting at the frst sector of
each partition on each physical drive. whiskeydelta uses random data from the heap to perform the overwrite task.
if the victim s machine is running windows xp or older, after destroying the data on the physical drive at the partition
boundaries, whiskeydelta then overwrites the entirety of the physical drive using eight threads to divvy the work load
before fnally using a single thread to overwrite the entirety of the physical drive in sequential sector order. for those
victims running windows vista and newer, the fnal task consists of overwriting 0x7c00 bytes (31,744 bytes) of the boot
sectors starting at sector 1 (lba o set 512) using random bytes from heap memory. the whiskeydelta change in behavior
based on the operating system s version relates to the changes that were introduced with windows vista and newer
regarding the way raw disk access is handled:9 vista and newer versions of windows can only access the boot sectors via
the \\.\physicaldrive interface.microsoft. changes to the file system and to the storage stack to restrict direct disk access and direct volume access in windows vista and in windows server 2008 31
january 2008. 30
5.1 whiskeydelta one
whiskeydelta-one provides the baseline for the whiskeydelta variants in term of functionality and design. consisting of
only 13 non-library functions, whiskeydelta-one is a streamlined executable that was designed and executed for the sole
purpose of data destruction. there are a few notable features found in whiskeydelta-one that are not found in whiskeydelta-two:
1. the task of obtaining the partition information for the physical drives (task 3) is a ioctl call
2. the fle selection criteria for the fle destruction task (task 5) is limited to a small subset of fle extensions for those
fles larger than 4 mb.
3. the fle destruction operation against selected fles is simple and independent of selection criteria, unlike whiskeydelta-two
4. the fle destruction operation is single-threaded, and therefore more time-consuming
whiskeydelta-one, despite its simplicity, does require a password for it to operate successfully. the task of decrypting
the names of the windows services the malware stops and decrypting the mbr trojan require a 32-byte alphanumeric
password to be supplied on the command line. while this does aide in hampering analysis of the mbr trojan, it also
provides additional work for the attacker to ensure the correct password is supplied. there is no error checking to ensure
the validity of the password so it is entirely possible for the attacker (or any analyst) to supply an incorrect password,
resulting in invalid strings for the names of the services and an invalid mbr trojan. however, given the signifcant
number of other destructive attacks the malware employs, it is unlikely that such a failure on the part of the attacker
would interfere in any data destruction given a long enough running time for the malware.
whiskeydelta-one uses a deviceiocontrol call for ioctl_disk_get_drive_layout_ex in order to obtain the
confguration of the physical drives. whiskeydelta-one stores this information in a global array that later operations
(specifcally the partition and sector overwrite tasks) will use once the mbr data has been corrupted.
when selecting fles for destruction during the fle destruction operation (task 5), whiskeydelta-one looks at the fle
extension to determine if a fle should be overwritten with random data. the bulk of the fles that whiskeydelta-one targets
(figure 5-3) fall under the category of source code and corporate documents.
.php .gul .alz
.asp .hwp .rar
.aspx .doc .zip
.jsp .docx .cpp
.java .xls .h
.kwp .xlsx .c
.eml .ppt
.pst .pptx
.wpd .pdf
.wri .mdb
figure 5 3: whiskeydelta one's file extension targeting list
the destruction process is size-dependent. for those fles that are less than 4 mb in size and have the desired fle
extension, the overwrite process consists of writing 256kb over the fle regardless of the fle s original size. if a fle is overmb in size, regardless of its fle extension, the overwrite process consists of overwriting the frst 256 kb of the fle and
the last 256 kb of the fle. regardless of whether or not a fle is selected for destruction by overwriting its data, the fle is
deleted via a call to deletefile. 31
5.2 whiskeydelta two
augmented with c2 reporting functionality, more robust fle selection criteria, the ability to modify the victim s
administrator account name, and constructed as a service executable under the service name rpcsecruity (complete
with misspelling), whiskeydelta-two is an escalation in functionality over whiskeydelta-one. whiskeydelta-two does
not require a command line argument to decrypt the mbr trojan or the names of the services to stop, meaning that the
services names and mbr trojan will always properly decode. whiskeydelta-two does, however, take a single command line
argument (a number) that it later transmits to a c2 server as part of a larger status report transmission.
the frst notable di erence in whiskeydelta-two is the inclusion of a function that attempts to rename the administrator s
account. spawned as its own thread, the function will sleep for 10 seconds before attempting to execute the code in figure 5-4.
srand(time(0));
w = rand();
x = rand();
y = rand();
z = rand();
sprintf(newname, hahaha _ %d%d%d%d , z, y, x, w);
sprintf(cmdline, /c net user administrator %s , newname);
winexec(cmdline, 0);
figure 5 4: whiskeydelta two's administrator account renaming code
if successful, the administrator account will be renamed with hahaha_ followed by 4 to 20 digits.
whiskeydelta-two modifes the registry, in much the same way as whiskeycharlie s [swap] command (see section 4), to
force the windows operating system to purge the page fle once the victim s machine shuts down. unlike whiskeycharlie,
however, whiskeydelta-two does not induce paging by flling large heap arrays with random data.
when obtaining partition information for the attached physical drives, whiskeydelta-two reads the drive s mbr and
parses the partition tables directly. the information about the partitions is then stored in a pair of global arrays which the
partition and sector overwrite operations later use to determine the size and o sets of the partitions and the overall size
of the drives.
having replaced the mbr with the mbr trojan, whiskeydelta-two reports its status by randomly selecting from the c2
server addresses hardcoded within itself and attempting to connect to the server. the communication between
whiskeydelta-two and its c2 server consists of a handshake/authentication test and two data transmissions encrypted
with the dnscalc-style encoding scheme. 32
dnscalc is an older malware family, used by several apt groups and frst profled in 2010, whose claim to
fame was the use of dns lookups for domain names that would return specifc ip addresses used to calculate
the listening port number for the c2 server. one notable feature of dnscalc was the use of a combination of
xor with an add operation and xor with a sub operation for the purposes of encrypting and decrypting data
streams. since at least 2011, the lazarus group has commandeered this technique for use in a variety of their
malware families. the dnscalc version of this encoding/decoding scheme performed the transformation
operation on each byte using two lines of c code such as
d += 122;
d ^= 25;
where the values 122 and 25 constitute the encryption and decryption keys. the lazarus group performs the
same operation in a single line of code, such as
d = (e ^ 25) 122
and
e = (d + 122) ^ 25
this subtle, but important, distinction in style indicates that the code was not directly copied from dnscalc,
but rather was inspired by dnscalc or another source that performs the same transform. it should be noted
that dnscalc modifed the gh0st rat myencode function, seen below, by reversing the order of operations
meaning that the lazarus group s use of the encoding scheme represents a derivation of an existing derivation.
char* myencode(char *str)
{
int i, len;
char *p;
char *s, *data;
len = strlen(str) + 1;
s = (char *)malloc(len);
memcpy(s, str, len);
for (i = 0; i < len; i++)
{
s[i] ^= 0x19;
s[i] += 0x86;
}
base64 _ encode(s, len, &data);
free(s);
return data;
}
the dnscalc-style encoding scheme code is heavily used throughout many of the various malware families for
which the lazarus group is responsible. 33
the handshake/authentication test consists of whiskeydelta-two generating a 16-byte random bu er that it encodes
using the dnscalc-style encoding before sending to the c2 server. the c2 server responds with the same 16-byte
random bu er encrypted with dnscalc-style encoding that whiskeydelta-two removes to reveal the decrypted 16
bytes. the decrypted response from the c2 server is then compared to the original 16-byte bu er to ensure they are
identical. failing this, the connection between the c2 server and the whiskeydelta-two malware is terminated.
while whiskeydelta-two s system of authentication seems somewhat rational at face value, it is heavily awed. since
the data bu er being sent to the c2 server is encoded with the reciprocal scheme that whiskeydelta-two uses to decrypt
the data stream, the c2 server merely needs to mirror requests from the whiskeydelta-two malware as the c2 server s
response. as a result, this provides absolutely no authentication for the malware.
after the authentication phase, communication between whiskeydelta-two and the c2 server takes the form of
dnscalc-style encoded datagrams. the format for the datagrams is straightforward, as seen in table 5-1, and is a
scheme used in a multitude of other lazarus group malware families, contributing to a shared code base that enabled
novetta to link seemingly unconnected malware families to the lazarus group. at a minimum, a datagram consists of a
type feld and a payload size feld contributing to a minimum datagram size of 6 bytes. an optional payload feld can have a
size of up to 262 bytes, meaning the maximum allowed datagram is 268 bytes in size.
offset size description4 bytes [dword] datagram type (set to 0x811)2 bytes [word] payload size (set to 0)variable (0 to 262 bytes) optional payload data
table 5 1: whiskeydelta two s datagram structure
after the initial authentication, whiskeydelta-two sends a login transmission to the c2 server. the login datagram
contains no payload data, and the type value is set to 0x811. following the login, whiskeydelta-two transmits a status
report to the c2 server that details the current state of the malware s destruction tasks. this status report datagram is 304
bytes in length and contains the information (and structure) defned in table 5-2.
offset size description4 bytes [dword] identifier as defined by the numerical value supplied on the command line when
whiskeydelta-two was activated260 bytes null-terminated string containing the victim s computer name as reported by
getcomputernamea4 byte number of lettered drives found on the victim s system4 bytes unused, possibly used to 8-byte alignment space8 bytes
[ularge_integer] total free space for all drives4 bytes number of physical drives found on the victim s system4 bytes number of files found on the victim s system4 bytes non-zero if victim s system is vista or newer4 bytes date and time that whiskeydelta-two was executed (as reported by time
function)4 bytes number of seconds from the administrator rename, page file purge setting change,
and mbr trojan installation4 bytes unused
table 5 2: whiskeydelta two s status report structure 34
the initial report to the c2 server only contains valid data for the identifer feld (o set 0), the computer name (o set 4),
the number of physical drives (o set 280), and the activation time (o set 292).
the fle destruction task (task 5) for whiskeydelta-two is signifcantly more involved than that of whiskeydelta-one.
the frst noticeable change is that for each drive that whiskeydelta-two enumerates, a new thread is generated to handle
the enumeration and destruction process, after frst cataloguing the amount of free space available on the drive (to be
later reported in o set 272 of the status report to the c2 server). the enumeration and fle selection process is more
specifc not only in which fle extensions are of interest, but also how these specifc fle types are destroyed. there are
three distinct criteria for determining if whiskeydelta-two overwrites a fle or not:
1. does the fle have an extension that the author(s) of whiskeydelta-two refer to as a backup fle (figure 5-5).
.log .myi .db2
.evt .frm .db
.bak .dbf .pls
.mdf .arc .plb
.ldf .rdo .pks
.sql .mdb .pkb
.myd .accdb .pck
figure 5 5: file extensions for "backup" files targeted by whiskeydelta two
2. is the fle larger than 4 mb
3. does the fle have an extension that the author(s) of whiskeydelta-two refer to as simply a fle (figure 5-6).
.php .docx .h .conf .png
.asp .xls .c .confg .iso
.aspx .xlsx .htm .ini .cs
.jsp .ppt .mht .avi
.java .pptx .html .wmv
.eml .pdf .xml .asf
.pst .alz .txt .gif
.gul .rar .inc .swf
.hwp .zip .js .tif
.doc .cpp .vb .mpg
figure 5 6: file extensions that whiskeydelta two targets for destruction
if a fle is deemed a backup fle by whiskeydelta-two, the overwrite function completely overwrites the fle with random
data. if a fle is larger than 4 mb, whiskeydelta-two will perform the same overwrite function that whiskeydelta-one
performs on fles larger than 4 mb, which consists of overwriting the frst and last 256 kb of the fle with random data.
if a fle has an extension that whiskeydelta-two classifes as simply a fle, the frst 256 kb of the fle are overwritten
with random data in the same manner that whiskeydelta-one would overwrite fles with targeted extensions. it should
be noted that before any fle destruction can occur, whiskeydelta-two generates a 256 kb bu er of random data, unlike
whiskeydelta-one, which uses whatever data is currently on the heap at the time.
after completing the fle destruction task, whiskeydelta-two again reports to the c2 server (though it may randomly 35
select a di erent server) with the full set of felds properly set and valid. after completing either the 0x7c00-byte
overwrite of the boot sectors (starting at sector 1) (if the victim is running windows vista or later) or the complete
overwrite of the logical drives and sectors (if the victim is running windows xp or older), whiskeydelta-two shuts down
the victim s computer; thanks to the modifed registry entry, this causes windows to purge the contents of the page fle. 36
6. [ddos bot] deltaalfa
observed as part of the ten days of rain campaign as well as being observed being dropped as part of the payload
deployed by indiagolf, deltaalfa is a distributed denial-of-service (ddos) bot. unlike the majority of ddos malware that
contact a central c2 server for instruction, deltaalfa uses fles stored on the victim s hard drive for the list of targets to
attack and to indicate the start time of an attack. the names of the target and start time fles di er by sample (see table
6-1) and are installed on the victim s system by the indiagolf installer.
start file filenames target filenames table 6 1: known filenames of the start and target files for deltaalfa
deltaalfa operates as a service dll supported by svchost. once activated by svchost, deltaalfa begins by decrypting a
data blob found within the resource section of its own binary. the data blob consists of strings representing function
names for the dynamic api loading functionality as well as key operational strings (e.g., user-agent strings, http request
format strings). the encryption scheme for the strings consists of a 7-byte rotating xor string.
deltaalfa dynamically loads a variety of api functions, many of which are not used by deltaalfa; this may be indicative of
a library that may be found in other, currently unobserved, malware families. deltaalfa then verifes the existence of the
start fle. if the start fle is found, the contents of the fle are loaded into memory as a varianttime object (e ectively a
double data type) and compared against the current datetime. prior to the comparison, the current datetime is modifed
to set the year to 2011, which is an odd conditional modifcation (see figure 6-1). if the start fle exists and the start time
has not passed, deltaalfa will sleep for 60 seconds before attempting the check again. if the start time has passed, the
start fle is deleted by deltaalfa which will shortcut the check for future launches of deltaalfa. 37
signed int attackstarttimecheck()
{
struct _systemtime systemtime;
double starttime;
double now_2011;
dword dwbytesread;
handle hfile = createfilea(" ", 0x80000000, 0, 0, 3, 128, 0);
if (hfile != -1 )
{
if ( readfile(hfile, &starttime, 8, &dwbytesread, 0)
&& dwbytesread == 8 )
{
closehandle(hfile);
getsystemtime(&systemtime);
systemtime.wyear = 2011;
systemtimetovarianttime(&systemtime, &now_2011);
if ( now_2011 < starttime)
return 0;
}
else
{
closehandle(hfile);
}
deletefilea(" ");
}
return 1;
}
figure 6 1: deltaalfa s function for determining if an attack should begin
deltaalfa loads the target fle into memory then decrypts the contents using a 128-bit key (that varies from sample to
sample) before parsing the contents. once parsed, each target has its own data structure that defnes the target, the types
of attacks to perform against the target, and the maximum number of attacks to perform (table 6-2).
offset size (in bytes) description
0x000 1 [boolean] if set, the record is a viable target (e.g. enabled )
0x001 32 [null-terminated string] target s hostname
0x021 128 [null-terminated string] target url (for http attacks)
0x0a1 128 [32 dwords] resolved ips for the target s hostname
0x121 4 [dword] number of resolved ips for the target s hostname
0x125 2 [word] target port
0x127 1 [boolean] enable dns resolver attack
0x128 1 [boolean] enable udp attack
0x129 1 [boolean] enable icmp (ping) attack
0x12a 4 [dword] maximum number of attacks against target
table 6 2: deltaalfa s target information structure
before issuing any attacks, deltaalfa spawns a continual resolver thread. the continual resolver thread is responsible
for refreshing the list of target ip addresses (the array at o set 0x0a1 within the target s information structure) for each
target. the continual resolver thread calls the function to refresh the ip addresses for each target once every 60 seconds. 38
the resolver s refresh function refreshes those targets whose resolved ips count is set to 0 (as indicated by the value at
o set 0x121 in the target s information structure). every 30 minutes, however, regardless of the number of resolved ips
for a target, the continual resolver thread forces the refresh function to resolve the target s hostname and update the list
of ip addresses.
a new attack thread is generated for each target. the attack thread can perform several di erent attacks as defned in
table 6-3. the dns attack is an exclusive attack in that, if specifed in the target s information structure, no other attack
type is permitted. however, the udp, icmp and http attacks can occur against the same target within the same target
informational record. note that not all samples support the dns, udp and icmp attacks, but all observed samples
support the http attack.
attack type description
dns attack
if the target s hostname field is non-empty, the hostname is resolved using the dnsquery api
function with a request for all dns record types to be returned. if the target s hostname field is
empty, however, all dns record types for , , , ,
and are requested through the dnsquery api function.
udp attack a udp packet containing 1024 bytes of random data is generated and transmitted to the target.
icmp attack
an icmp echo-reply packet is generated and transmitted via a raw socket to the target. the body of
the echo-reply contains 200 bytes of random data. the identifier and sequence numbers of the packet
are sequential (starting at 1) for each packet generated.
http attack a burst of 5 http get requests are made to the target s hostname for the target url.
table 6 3: attack types of deltaalfa
the http attack has the most variety in its appearance when compared to the other deltaalfa attack types. the basic
structure of the http attack consists of constructing an http get request manually with the format described in figure 6-2.
get <target s hostname plus the target url> http/1.1
accept: <varies>
accept-language: ko
user-agent: <varies>
accept-encoding: gzip, de ate
cache-control: no-store, must-revalidate
proxy-connection: keep-alive
host: www.<target s hostname>
figure 6 2: deltaalfa s http attack get request structure 39
the value supplied to the accept: feld is randomly selected from one of fve hardcoded strings (figure 6-3). likewise,
the user-agent: feld can be one of seven hardcoded strings (figure 6-4) selected at random. the cache-control:
no-store, must-revalidate entry is randomly inserted or omitted for each attack iteration.
*/*
text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/x-shockwave- ash, */*
image/jpeg, application/x-ms-application, image/gif, application/xaml+xml, image/pjpeg,
application/x-ms-xbap, */*
image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave- ash, application/ -excel, application/ -powerpoint, application/msword, */*
figure 6 3: possible accept: field values
mozilla/5.0 (x11; u; linux i686; ko-kr; rv: ) gecko/2008111217 fedora/3.0.4-1.fc10
firefox/3.0.4
mozilla/5.0 (windows; u; windows nt 5.1; ko; rv: ) gecko/20100722 firefox/3.6.8
mozilla/4.0 (compatible; msie 7.0; windows nt 5.1)
mozilla/4.0 (compatible; msie 8.0; windows nt 6.1; trident/4.0; slcc2; .net clr 2.0.50727;
.net clr 3.5.30729; .net clr 3.0.30729; media center pc 6.0)
mozilla/4.0 (compatible; msie 8.0; windows nt 5.1; trident/4.0)
mozilla/4.0 (compatible; msie 8.0; windows nt 5.1; trident/4.0; infopath.2)
figure 6 4: possible user agent: field values 40
7. [ddos bot] deltabravo
deltabravo is a ddos bot that uses the winpcap npf driver in order to generate raw network packets from a victim s
machine. observed being dropped alongside romeoindia by indiafoxtrot, deltabravo is structurally a fairly simplistic
ddos bot that performs a somewhat convoluted handshake between itself and its controlling server in order to receive
targeting information.
deltabravo, upon activation, operates in one of two modes: driver installation mode and dos-bot mode. if called with only
a single command line argument, the malware activates in driver installation mode. this mode determines if the victim s
operating system is 32 or 64-bit and drops the architecture-appropriate winpcap npf driver from the deltabravo s own pe
resource section to the victim s %sysdir%\drivers directory as .
if activated with 4 or more command line arguments, deltabravo frst activates driver installation mode before entering
dos-bot mode (failure to provide the 4 command line arguments results in deltabravo skipping dos-bot mode). the second
command line argument supplied to deltabravo specifes the address of the c2 server while the third command line
argument contains the c2 server s listening port. deltabravo begins by determining the victim s mac address and hard
drive serial number which it uses to generate a md5 hash that represents the victim s unique identifer. this information
is transmitted to the c2 server as part of the handshake along with a ag that indicates if the c2 server s ip address exists
within the iana private ip space ( /8, /12, or /16).
after establishing a connection to the c2 server, the c2 server ultimately transmits a dos attack command. in order to
fulfll the attack request, deltabravo activates the winpcap driver (via wpcap_adapter_open) after generating an
attack packet. the c2 server sends both the type of packet to generate and the number of times the packet is transmitted.
after completing its attack, deltabravo will sleep for 100ms before requesting a new attack directive from the c2 server.
if for any reason deltabravo exits the communication/attack cycle, the binary generates a suicide script named using a wsprintf statement with the following format string:
wsprintfa(script, ":l1\r\ndel \"%s\"\r\nif exist \"%s\" goto l1\r\ndel \"%s\"\r\n",
szbinaryname, szbinaryname, szscriptname);
figure 7 1: deltabravo's suicide script generator
once generated, deltabravo activates the script via a call to createprocess before terminating. 41
8. [ddos bot] deltacharlie
much like deltabravo (see section 7), deltacharlie is a ddos bot that relies on the winpcap npf driver for the generation
of raw network packets. unlike deltabravo, however, deltacharlie is capable of the following basic instructions: download and execute a binary from the c2 server download a new confguration from the c2 server update its own binary terminate its own process activate a ddos attack terminate a ddos attack
deltacharlie operates as a svchost-based service (netplug). after servicemain is activated by the operating system
and the necessary service framework code has executed, deltacharlie determines its exclusivity on the victim s system by
looking for the existence of a named mutex with the identifer global\netplugdiscovery0.7.
the confguration for deltacharlie exists within the same directory as the deltacharlie binary under the name .
the confguration fle is encrypted with rc4 (with the password initializesecuritycontexta). deltacharlie must
successfully load the confguration in order to operate; a failure to do so results in deltacharlie silently terminating.
deltacharlie is multithreaded: in addition to the main thread, deltacharlie spins up a thread whose only function is the
cataloguing of attack information into an unencrypted log fle located as %sysdir% . the log
fle identifes the number of packets and the rate at which the packets are sent for each attack issued by the c2 server.
deltacharlie connects to the c2 server after iterating through the three c2 server addresses in the confguration.
deltacharlie resolves the c2 server address and then applies an xor 0x579c3a53 to the resolved address in order to
reveal the true c2 server ip address. deltacharlie then uses a handshake that consists of generating a 16-byte random
bu er and then encrypting the bu er using the dnscalc-style encoding seen in several other malware families
attributed to the lazarus group. the bu er is sent to the c2 server, and the c2 server responds by sending back the
16-byte bu er decrypted. if the original random 16-byte bu er matches the 16-bytes returned by the c2 server, then the
handshake is successful and communication between the c2 server and deltacharlie can commence.
deltacharlie then requests the c2 server s current time and calculates the di erence, in seconds, between the c2 server s
time and its own. if deltacharlie has any outstanding commands that it has yet to execute, it transmits the information
to the c2 server along with the current attack log ( ). deltacharlie then transmits information about the
victim s system (specifcally the hard drive s serial number, computer name, and network ip address) to the c2 server.
deltacharlie, much like sierrajuliett-mikeone, uses command fles for the transmission of commands from the c2 to
the malware. the commands are given unique, incremental id numbers. in order to keep track of commands that have
already been executed, thereby avoiding unnecessary network load on the c2 server, deltacharlie transmits the command
id number of the last command it executed. the c2 server, in turn, sends the next command to the malware. the
command fles are both encrypted and signed. each command fle contains a md5 hash encrypted using a private rsa
key. deltacharlie uses the following public key to decrypt the md5 hash value:. 42
the md5 hash is located between bytes 4 and 132 of the command fle while the md5 hash relates to the data that follows the
132nd byte. deltacharlie calculates the md5 hash of the data that follows the encrypted md5 header and compares it to the
decrypted md5 hash value. if the two values are identical, deltacharlie determines that the command fle is valid. the data
that follows the encrypted md5 header is encrypted with rc4 (using the password initializesecuritycontexta).
the entirety of the command fle validation is remarkably similar to the method that sierrajuliett-mikeone employs for
verifying its command fles.
after decrypting the command fle, deltacharlie sends the status of the decryption to the c2 server and then dispatches
the appropriate handler for the command type. deltacharlie supports six di erent commands identifed in table 8-1.
command
identifier
internal
command name descriptiondownexec downloads and potentially executes a filechngbotconfg alters the current configuration and saves the configuration to diskbotupdate replaces the contents of the current deltacharlie binary with a new binary imagebotdie terminates the current deltacharlie processstarts a new dos attack by generating a new attack thread.stops an active dos attack.
table 8 1: deltacharlie commands
the dos attacks that deltacharlie can perform consist of ntp attacks, carrier-grade nat (cgn) attacks, and dns
attacks. the kicko of any attack is followed by a two second sleep interval. 43
9. conclusions
the destructive malware within the lazarus group s collection ranges from simplistic to moderately advanced in
construction and style. however, regardless of the structure and complexity of the code for any particular tool, their operational e ectiveness is undeniable. the author(s) behind these destructive malware families have developed a set of tools
capable of in icting signifcant damage against a target either directly, as in the case of the whiskey families, or remotely,
via the delta families. this further emphasizes that even a moderately capable adversary with minimal resources is able to
perform asymmetric cyberwar against a large target.mclean, virginia headquartersjones branch drive
5th floor
