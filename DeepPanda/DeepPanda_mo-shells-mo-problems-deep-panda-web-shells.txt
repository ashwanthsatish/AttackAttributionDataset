crowdstrike presents mo shells mo problems a four part series featuring two unique web shells used by a chinese threat group we call deep panda. the series will culminate with a crowdcast in april 2014 detailing a case study of the incident response investigation conducted to identify these web shells. special thanks to josh phillips of the crowdstrike global intelligence team for providing the technical analysis in this blog post. today we ll cover part one of this series, which provides an overview of what web shells are, functionality of two web shells recently identified during an incident response investigation and how they were leveraged by the attacker. parts two through four will provide details on successful analytical techniques you can use to discover web shells within your environment: a web shell is a file containing backdoor functionality written in a web scripting language such asp, aspx, php or jsp. when a web shell is hosted on an internet facing victim system, an adversary can remotely access the system to perform malicious actions. deep panda is a china based threat group crowdstrike has observed targeting companies in the defense, legal, telecommunication and financial industries. crowdstrike has observed deep panda adopting web shells as their primary access back into a victim organization. this is an interesting shift as web shells have typically been seen as only a first stage into obtaining a persistent foothold in an environment. previously, web shells were quickly abandoned once persistent second stage malware was successfully beaconing. using a web shell as a primary backdoor gives deep panda several advantages: low to virtually no detection by antivirus products
the absence of command and control beacon traffic
impossible to block known malicious ip addresses to a web server since adversary can easily change their source ip address
cookie and http header authentication aware web shells avoid being enumerated by search engines and restrict access, further reducing their network footprint
to assist organizations with identifying web shells in their environment, this post will cover two popular deep panda web shells. by gaining insight into their capabilities and footprint, organizations should find it feasible to detect and remediate these backdoors. is an example of an early stage web shell used to build an initial foothold within a network. after it is replaced by more robust backdoors, it may be left in place as a last resort should remediation take place. at a diminutive 28 bytes, it is one of the smallest active server page (asp) backdoors in the wild. in a recent case, we witnessed this web shell written to a standalone file (named ), but it could easily be injected into an existing page, making it even stealthier. the code for this web shell can be found below: asp uses microsoft visual basic (vbscript) as its implementation language. the code above uses the chr() function to convert an integer into a character, which is then passed as an argument to the asp request() object. the request() object will search the query string for any keys matching the input. in our case, the code is equivalent to request.querystring( * ). the request object will look for chr(42) which is an asterisk (*), returning whatever is passed to it in a http get or post. next, the execute() function will execute any value returned by the lookup. effectively, an attacker can form a request that will execute any vbscript code. as you might imagine, this is a powerful capability. for example, this code can perform any of the following actions: this web shell is an example of a thick client shell, meaning that while the server side code is quite small, attackers typically use a larger gui client to construct the sent commands. the client gui runs on the attacker s system and hence is not typically found within the victim network. as a simple example of an encoded command, the following get request would cause the backdoor to execute the code response.write( <h1>hello world</h1> ) and would render hello world to be printed in the web browser: is an excellent example of a more robust web shell used to replace deep panda s traditional beaconing command and control infrastructure. it is an backdoor written in c#, with far more capabilities than we saw with the sample. the web shell supports a form of authentication to protect against unauthorized access. this prevents its discovery from search engine indexing, vulnerability scanning tools and other unauthorized access to the backdoor. in order to bypass authentication, a user session must satisfy one of three options: pass a cookie with the name <redacted>
set the keep-alive http header to 320
set language http header to contain es-dn
since web shells are text-based, we can easily see how this authentication takes place: table 5: authentication code first, the code checks if a cookie by the name of cp exists. if so, the response object has its end() method invoked, denying the user access. next, the code uses the isvaliduser()method and checks the hyper text transport protocol (http) headers for the keep-alive value, which, if equal to 320, will return true. if the value does not equal 320 the isvaliduser()method iterates over the request.userlanguages collection searching for a language named es-dn, and if found, the isvaliduser() method will return true. if neither check passes, the code returns false and the code will finally check for the presence of a cookie named <redacted>. if the cookie is present, the authentication step is satisfied. if not, a blank web page with no content is displayed. after successful authentication, the attacker is provided with the following page: web shells packs a large amount of functionality into a compact interface. it provides the following capabilities: enumerate attached drives
utilize built in sql functions to connect to database backend
run sql queries and statements
download, upload and read files
directory listing
execute active directory requests
compile and execute arbitrary c# source code
impersonate a user
the web shell supports 8 main commands, with most command execution via transact-sql using the xp_cmdshell function. this command depends on the contents of the first unlabeled textbox1. if unlabeledtextbox1 is empty, the code will enumerate attached drives. provider= or driver= will connect using the oledbconnection class.
data source= the code will connect using the sqlconnection class.
iis:// if this appears in unlabeled textbox1, the code will use data from the second unlabeled textbox2 to execute active directory requests.
down this command also depends on the text contained in the unlabeled textbox1. if the field is left empty, the code will assume a valid path to a file on the local machine and will read and display contents to user. data source= the code will assume that the unlabeled textbox2 contains a valid sql query and will execute it and display the results.
http:// if this appears in unlabeled textbox1, download content from the assumed url.
$sex if this appears in unlabeled textbox1, pass the contents to the server.execute() method.
bf execute contents in unlabeled textbox1 as a sql query and return binary data to adversary. execute contents in unlabeled textbox1 as a sql statement and return valid textual data to adversary. upload the file chosen by the choose file button and save it to a temporary table in the database file worktbl in chunks of 10240 bytes. then executes xp_cmdshell (which executes the bulk copy program) to copy the data from that table to a file whose name is specified in unlabeled textbox2. after the file is saved, the code deletes the temporary table. if unlabeled textbox1 is a local file on infected system, the file is read and displayed to attacker. \ if unlabeled textbox1 starts with \, use xp_cmdshell to execute the copy command to copy file to %windir% . then, issue the dir command and display results to user. finally, delete the temporary file %windir% .
dir perform active directory queries. the code handles create, delete, set, get, and enum queries, while any query not matching those is executed directly. all commands are executed using the system.directoryservices api. simple wrapper around the csharpcodeprovider api, allowing the adversary to compile and execute arbitrary c# source code. attempt to use the username, password, and domain from the user, pass and domain fields and logonusera() win32 api function to impersonate a specific user. specifies whether commands run from the exec button will have their output redirected and displayed to the adversary when the command is finished executing. in short, provides an adversary with a very stealthy means of near full control of the server on which it resides. this stealth might be its most important attribute. as we will see, identifying web shells can be much harder than finding malicious binaries. in our next post, we will discuss techniques for identifying web shells.